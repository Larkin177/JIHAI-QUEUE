import { createRequire } from "node:module";
import { deserializeProgramOnly } from "../dist/generated/deserialize.js";
import { pathToFileURL } from "node:url";
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), __copyProps = (to, from, except, desc) => {
	if (from && typeof from == "object" || typeof from == "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) key = keys[i], !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
		get: ((k) => from[k]).bind(null, key),
		enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
	});
	return to;
}, __toESM = (mod, isNodeMode, target) => (target = mod == null ? {} : __create(__getProtoOf(mod)), __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: !0
}) : target, mod));
function getErrorMessage(err) {
	try {
		if (err instanceof Error) {
			let { stack } = err;
			if (typeof stack == "string" && stack !== "") return stack;
		}
		let { message } = err;
		if (typeof message == "string" && message !== "") return message;
	} catch {}
	return "Unknown error";
}
const { prototype: ArrayPrototype, from: ArrayFrom } = Array, { getPrototypeOf, hasOwn: hasOwn$1, prototype: ObjectPrototype } = Object, { ownKeys } = Reflect, IteratorSymbol = Symbol.iterator, FIXER = Object.freeze({
	insertTextBefore(nodeOrToken, text) {
		let start = nodeOrToken.range[0];
		return {
			range: [start, start],
			text
		};
	},
	insertTextBeforeRange(range, text) {
		let start = range[0];
		return {
			range: [start, start],
			text
		};
	},
	insertTextAfter(nodeOrToken, text) {
		let end = nodeOrToken.range[1];
		return {
			range: [end, end],
			text
		};
	},
	insertTextAfterRange(range, text) {
		let end = range[1];
		return {
			range: [end, end],
			text
		};
	},
	remove(nodeOrToken) {
		return {
			range: nodeOrToken.range,
			text: ""
		};
	},
	removeRange(range) {
		return {
			range,
			text: ""
		};
	},
	replaceText(nodeOrToken, text) {
		return {
			range: nodeOrToken.range,
			text
		};
	},
	replaceTextRange(range, text) {
		return {
			range,
			text
		};
	}
});
function getFixes(diagnostic, internal) {
	let { fix } = diagnostic;
	if (typeof fix != "function") return null;
	let fixes = fix.call(diagnostic, FIXER);
	if (!fixes) return null;
	if (IteratorSymbol in fixes) {
		let isCloned = !1;
		(getPrototypeOf(fixes) !== ArrayPrototype || hasOwn$1(fixes, "toJSON")) && (fixes = ArrayFrom(fixes), isCloned = !0);
		let fixesLen = fixes.length;
		if (fixesLen === 0) return null;
		for (let i = 0; i < fixesLen; i++) {
			let fix$1 = fixes[i];
			if (!fix$1) {
				if (fixes = fixes.filter(Boolean), fixes.length === 0) return null;
				isCloned = !0, i--;
				continue;
			}
			let conformedFix = validateAndConformFix(fix$1);
			conformedFix !== fix$1 && (isCloned === !1 && (fixes = fixes.slice(), isCloned = !0), fixes[i] = conformedFix);
		}
	} else fixes = [validateAndConformFix(fixes)];
	if (internal.isFixable === !1) throw Error("Fixable rules must set the `meta.fixable` property to \"code\" or \"whitespace\".");
	return fixes;
}
function validateAndConformFix(fix) {
	let { range, text } = fix;
	if (!range || typeof range[0] != "number" || typeof range[1] != "number") throw Error(`Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);
	let fixPrototype = getPrototypeOf(fix);
	return (fixPrototype === ObjectPrototype || fixPrototype === null) && ownKeys(fix).length === 2 && getPrototypeOf(range) === ArrayPrototype && !hasOwn$1(range, "toJSON") && range.length === 2 && typeof text == "string" ? fix : {
		range: [range[0], range[1]],
		text: String(text)
	};
}
var keys_default = Object.freeze({
	DebuggerStatement: [],
	EmptyStatement: [],
	Literal: [],
	PrivateIdentifier: [],
	Super: [],
	TemplateElement: [],
	ThisExpression: [],
	JSXClosingFragment: [],
	JSXEmptyExpression: [],
	JSXIdentifier: [],
	JSXOpeningFragment: [],
	JSXText: [],
	TSAnyKeyword: [],
	TSBigIntKeyword: [],
	TSBooleanKeyword: [],
	TSIntrinsicKeyword: [],
	TSJSDocUnknownType: [],
	TSNeverKeyword: [],
	TSNullKeyword: [],
	TSNumberKeyword: [],
	TSObjectKeyword: [],
	TSStringKeyword: [],
	TSSymbolKeyword: [],
	TSThisType: [],
	TSUndefinedKeyword: [],
	TSUnknownKeyword: [],
	TSVoidKeyword: [],
	AccessorProperty: [
		"decorators",
		"key",
		"typeAnnotation",
		"value"
	],
	ArrayExpression: ["elements"],
	ArrayPattern: [
		"decorators",
		"elements",
		"typeAnnotation"
	],
	ArrowFunctionExpression: [
		"typeParameters",
		"params",
		"returnType",
		"body"
	],
	AssignmentExpression: ["left", "right"],
	AssignmentPattern: [
		"decorators",
		"left",
		"right",
		"typeAnnotation"
	],
	AwaitExpression: ["argument"],
	BinaryExpression: ["left", "right"],
	BlockStatement: ["body"],
	BreakStatement: ["label"],
	CallExpression: [
		"callee",
		"typeArguments",
		"arguments"
	],
	CatchClause: ["param", "body"],
	ChainExpression: ["expression"],
	ClassBody: ["body"],
	ClassDeclaration: [
		"decorators",
		"id",
		"typeParameters",
		"superClass",
		"superTypeArguments",
		"implements",
		"body"
	],
	ClassExpression: [
		"decorators",
		"id",
		"typeParameters",
		"superClass",
		"superTypeArguments",
		"implements",
		"body"
	],
	ConditionalExpression: [
		"test",
		"consequent",
		"alternate"
	],
	ContinueStatement: ["label"],
	Decorator: ["expression"],
	DoWhileStatement: ["body", "test"],
	ExportAllDeclaration: [
		"exported",
		"source",
		"attributes"
	],
	ExportDefaultDeclaration: ["declaration"],
	ExportNamedDeclaration: [
		"declaration",
		"specifiers",
		"source",
		"attributes"
	],
	ExportSpecifier: ["local", "exported"],
	ExpressionStatement: ["expression"],
	ForInStatement: [
		"left",
		"right",
		"body"
	],
	ForOfStatement: [
		"left",
		"right",
		"body"
	],
	ForStatement: [
		"init",
		"test",
		"update",
		"body"
	],
	FunctionDeclaration: [
		"id",
		"typeParameters",
		"params",
		"returnType",
		"body"
	],
	FunctionExpression: [
		"id",
		"typeParameters",
		"params",
		"returnType",
		"body"
	],
	Identifier: ["decorators", "typeAnnotation"],
	IfStatement: [
		"test",
		"consequent",
		"alternate"
	],
	ImportAttribute: ["key", "value"],
	ImportDeclaration: [
		"specifiers",
		"source",
		"attributes"
	],
	ImportDefaultSpecifier: ["local"],
	ImportExpression: ["source", "options"],
	ImportNamespaceSpecifier: ["local"],
	ImportSpecifier: ["imported", "local"],
	LabeledStatement: ["label", "body"],
	LogicalExpression: ["left", "right"],
	MemberExpression: ["object", "property"],
	MetaProperty: ["meta", "property"],
	MethodDefinition: [
		"decorators",
		"key",
		"value"
	],
	NewExpression: [
		"callee",
		"typeArguments",
		"arguments"
	],
	ObjectExpression: ["properties"],
	ObjectPattern: [
		"decorators",
		"properties",
		"typeAnnotation"
	],
	ParenthesizedExpression: ["expression"],
	Program: ["body"],
	Property: ["key", "value"],
	PropertyDefinition: [
		"decorators",
		"key",
		"typeAnnotation",
		"value"
	],
	RestElement: [
		"decorators",
		"argument",
		"typeAnnotation"
	],
	ReturnStatement: ["argument"],
	SequenceExpression: ["expressions"],
	SpreadElement: ["argument"],
	StaticBlock: ["body"],
	SwitchCase: ["test", "consequent"],
	SwitchStatement: ["discriminant", "cases"],
	TaggedTemplateExpression: [
		"tag",
		"typeArguments",
		"quasi"
	],
	TemplateLiteral: ["quasis", "expressions"],
	ThrowStatement: ["argument"],
	TryStatement: [
		"block",
		"handler",
		"finalizer"
	],
	UnaryExpression: ["argument"],
	UpdateExpression: ["argument"],
	V8IntrinsicExpression: ["name", "arguments"],
	VariableDeclaration: ["declarations"],
	VariableDeclarator: ["id", "init"],
	WhileStatement: ["test", "body"],
	WithStatement: ["object", "body"],
	YieldExpression: ["argument"],
	JSXAttribute: ["name", "value"],
	JSXClosingElement: ["name"],
	JSXElement: [
		"openingElement",
		"children",
		"closingElement"
	],
	JSXExpressionContainer: ["expression"],
	JSXFragment: [
		"openingFragment",
		"children",
		"closingFragment"
	],
	JSXMemberExpression: ["object", "property"],
	JSXNamespacedName: ["namespace", "name"],
	JSXOpeningElement: [
		"name",
		"typeArguments",
		"attributes"
	],
	JSXSpreadAttribute: ["argument"],
	JSXSpreadChild: ["expression"],
	TSAbstractAccessorProperty: [
		"decorators",
		"key",
		"typeAnnotation"
	],
	TSAbstractMethodDefinition: ["key", "value"],
	TSAbstractPropertyDefinition: [
		"decorators",
		"key",
		"typeAnnotation"
	],
	TSArrayType: ["elementType"],
	TSAsExpression: ["expression", "typeAnnotation"],
	TSCallSignatureDeclaration: [
		"typeParameters",
		"params",
		"returnType"
	],
	TSClassImplements: ["expression", "typeArguments"],
	TSConditionalType: [
		"checkType",
		"extendsType",
		"trueType",
		"falseType"
	],
	TSConstructSignatureDeclaration: [
		"typeParameters",
		"params",
		"returnType"
	],
	TSConstructorType: [
		"typeParameters",
		"params",
		"returnType"
	],
	TSDeclareFunction: [
		"id",
		"typeParameters",
		"params",
		"returnType",
		"body"
	],
	TSEmptyBodyFunctionExpression: [
		"id",
		"typeParameters",
		"params",
		"returnType"
	],
	TSEnumBody: ["members"],
	TSEnumDeclaration: ["id", "body"],
	TSEnumMember: ["id", "initializer"],
	TSExportAssignment: ["expression"],
	TSExternalModuleReference: ["expression"],
	TSFunctionType: [
		"typeParameters",
		"params",
		"returnType"
	],
	TSImportEqualsDeclaration: ["id", "moduleReference"],
	TSImportType: [
		"argument",
		"options",
		"qualifier",
		"typeArguments"
	],
	TSIndexSignature: ["parameters", "typeAnnotation"],
	TSIndexedAccessType: ["objectType", "indexType"],
	TSInferType: ["typeParameter"],
	TSInstantiationExpression: ["expression", "typeArguments"],
	TSInterfaceBody: ["body"],
	TSInterfaceDeclaration: [
		"id",
		"typeParameters",
		"extends",
		"body"
	],
	TSInterfaceHeritage: ["expression", "typeArguments"],
	TSIntersectionType: ["types"],
	TSJSDocNonNullableType: ["typeAnnotation"],
	TSJSDocNullableType: ["typeAnnotation"],
	TSLiteralType: ["literal"],
	TSMappedType: [
		"key",
		"constraint",
		"nameType",
		"typeAnnotation"
	],
	TSMethodSignature: [
		"key",
		"typeParameters",
		"params",
		"returnType"
	],
	TSModuleBlock: ["body"],
	TSModuleDeclaration: ["id", "body"],
	TSNamedTupleMember: ["label", "elementType"],
	TSNamespaceExportDeclaration: ["id"],
	TSNonNullExpression: ["expression"],
	TSOptionalType: ["typeAnnotation"],
	TSParameterProperty: ["decorators", "parameter"],
	TSParenthesizedType: ["typeAnnotation"],
	TSPropertySignature: ["key", "typeAnnotation"],
	TSQualifiedName: ["left", "right"],
	TSRestType: ["typeAnnotation"],
	TSSatisfiesExpression: ["expression", "typeAnnotation"],
	TSTemplateLiteralType: ["quasis", "types"],
	TSTupleType: ["elementTypes"],
	TSTypeAliasDeclaration: [
		"id",
		"typeParameters",
		"typeAnnotation"
	],
	TSTypeAnnotation: ["typeAnnotation"],
	TSTypeAssertion: ["typeAnnotation", "expression"],
	TSTypeLiteral: ["members"],
	TSTypeOperator: ["typeAnnotation"],
	TSTypeParameter: [
		"name",
		"constraint",
		"default"
	],
	TSTypeParameterDeclaration: ["params"],
	TSTypeParameterInstantiation: ["params"],
	TSTypePredicate: ["parameterName", "typeAnnotation"],
	TSTypeQuery: ["exprName", "typeArguments"],
	TSTypeReference: ["typeName", "typeArguments"],
	TSUnionType: ["types"]
});
const { max } = Math, textDecoder = new TextDecoder("utf-8", { ignoreBOM: !0 });
let buffer = null, hasBOM = !1, sourceText = null, sourceByteLen = 0, ast = null;
function setupSourceForFile(bufferInput, hasBOMInput) {
	buffer = bufferInput, hasBOM = hasBOMInput;
}
function initSourceText() {
	let { uint32 } = buffer;
	sourceByteLen = uint32[uint32[536870902] + 16 >> 2], sourceText = textDecoder.decode(buffer.subarray(0, sourceByteLen));
}
function initAst() {
	sourceText === null && initSourceText(), ast = deserializeProgramOnly(buffer, sourceText, sourceByteLen, getNodeLoc);
}
function resetSource() {
	buffer = null, sourceText = null, ast = null, resetLines();
}
const SOURCE_CODE = Object.freeze({
	get text() {
		return sourceText === null && initSourceText(), sourceText;
	},
	get hasBOM() {
		return hasBOM;
	},
	get ast() {
		return ast === null && initAst(), ast;
	},
	get scopeManager() {
		throw Error("`sourceCode.scopeManager` not implemented yet");
	},
	get visitorKeys() {
		return keys_default;
	},
	get parserServices() {
		throw Error("`sourceCode.parserServices` not implemented yet");
	},
	get lines() {
		return lines.length === 0 && initLines(), lines;
	},
	getText(node, beforeCount, afterCount) {
		if (sourceText === null && initSourceText(), !node) return sourceText;
		let { range } = node, start = range[0], end = range[1];
		return beforeCount && (start = max(start - beforeCount, 0)), afterCount && (end += afterCount), sourceText.slice(start, end);
	},
	getAllComments() {
		throw Error("`sourceCode.getAllComments` not implemented yet");
	},
	getCommentsBefore(nodeOrToken) {
		throw Error("`sourceCode.getCommentsBefore` not implemented yet");
	},
	getCommentsAfter(nodeOrToken) {
		throw Error("`sourceCode.getCommentsAfter` not implemented yet");
	},
	getCommentsInside(node) {
		throw Error("`sourceCode.getCommentsInside` not implemented yet");
	},
	isSpaceBetween(nodeOrToken1, nodeOrToken2) {
		throw Error("`sourceCode.isSpaceBetween` not implemented yet");
	},
	isGlobalReference(node) {
		throw Error("`sourceCode.isGlobalReference` not implemented yet");
	},
	getTokens(node, countOptions, afterCount) {
		throw Error("`sourceCode.getTokens` not implemented yet");
	},
	getFirstToken(node, skipOptions) {
		throw Error("`sourceCode.getFirstToken` not implemented yet");
	},
	getFirstTokens(node, countOptions) {
		throw Error("`sourceCode.getFirstTokens` not implemented yet");
	},
	getLastToken(node, skipOptions) {
		throw Error("`sourceCode.getLastToken` not implemented yet");
	},
	getLastTokens(node, countOptions) {
		throw Error("`sourceCode.getLastTokens` not implemented yet");
	},
	getTokenBefore(nodeOrToken, skipOptions) {
		throw Error("`sourceCode.getTokenBefore` not implemented yet");
	},
	getTokensBefore(nodeOrToken, countOptions) {
		throw Error("`sourceCode.getTokensBefore` not implemented yet");
	},
	getTokenAfter(nodeOrToken, skipOptions) {
		throw Error("`sourceCode.getTokenAfter` not implemented yet");
	},
	getTokensAfter(nodeOrToken, countOptions) {
		throw Error("`sourceCode.getTokensAfter` not implemented yet");
	},
	getTokensBetween(nodeOrToken1, nodeOrToken2, countOptions) {
		throw Error("`sourceCode.getTokensBetween` not implemented yet");
	},
	getFirstTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions) {
		throw Error("`sourceCode.getFirstTokenBetween` not implemented yet");
	},
	getFirstTokensBetween(nodeOrToken1, nodeOrToken2, countOptions) {
		throw Error("`sourceCode.getFirstTokensBetween` not implemented yet");
	},
	getLastTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions) {
		throw Error("`sourceCode.getLastTokenBetween` not implemented yet");
	},
	getLastTokensBetween(nodeOrToken1, nodeOrToken2, countOptions) {
		throw Error("`sourceCode.getLastTokensBetween` not implemented yet");
	},
	getTokenByRangeStart(index, rangeOptions) {
		throw Error("`sourceCode.getTokenByRangeStart` not implemented yet");
	},
	getNodeByRangeIndex(index) {
		throw Error("`sourceCode.getNodeByRangeIndex` not implemented yet");
	},
	getLocFromIndex: getLineColumnFromOffset,
	getIndexFromLoc: getOffsetFromLineColumn,
	commentsExistBetween(nodeOrToken1, nodeOrToken2) {
		throw Error("`sourceCode.commentsExistBetween` not implemented yet");
	},
	getAncestors,
	getDeclaredVariables(node) {
		throw Error("`sourceCode.getDeclaredVariables` not implemented yet");
	},
	getScope(node) {
		throw Error("`sourceCode.getScope` not implemented yet");
	},
	markVariableAsUsed(name, refNode) {
		throw Error("`sourceCode.markVariableAsUsed` not implemented yet");
	}
});
function getAncestors(node) {
	let ancestors$1 = [];
	for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) ancestors$1.push(ancestor);
	return ancestors$1.reverse();
}
const { defineProperty } = Object, LINE_BREAK_PATTERN = /\r\n|[\r\n\u2028\u2029]/gu, lines = [], lineStartOffsets = [0];
function initLines() {
	sourceText === null && initSourceText();
	let lastOffset = 0, offset, match;
	for (; match = LINE_BREAK_PATTERN.exec(sourceText);) offset = match.index, lines.push(sourceText.slice(lastOffset, offset)), lineStartOffsets.push(lastOffset = offset + match[0].length);
	lines.push(sourceText.slice(lastOffset));
}
function resetLines() {
	lines.length = 0, lineStartOffsets.length = 1;
}
function getLineColumnFromOffset(offset) {
	if (typeof offset != "number" || offset < 0 || (offset | 0) !== offset) throw TypeError("Expected `offset` to be a non-negative integer.");
	if (lines.length === 0 && initLines(), offset > sourceText.length) throw RangeError(`Index out of range (requested index ${offset}, but source text has length ${sourceText.length}).`);
	return getLineColumnFromOffsetUnchecked(offset);
}
function getLineColumnFromOffsetUnchecked(offset) {
	let low = 0, high = lineStartOffsets.length, mid;
	do
		mid = (low + high) / 2 | 0, offset < lineStartOffsets[mid] ? high = mid : low = mid + 1;
	while (low < high);
	return {
		line: low,
		column: offset - lineStartOffsets[low - 1]
	};
}
function getOffsetFromLineColumn(loc) {
	if (typeof loc == "object" && loc) {
		let { line, column } = loc;
		if (typeof line == "number" && typeof column == "number" && (line | 0) === line && (column | 0) === column) {
			lines.length === 0 && initLines();
			let linesCount = lineStartOffsets.length;
			if (line <= 0 || line > linesCount) throw RangeError(`Line number out of range (line ${line} requested). Line numbers should be 1-based, and less than or equal to number of lines in file (${linesCount}).`);
			if (column < 0) throw RangeError(`Invalid column number (column ${column} requested).`);
			let lineOffset = lineStartOffsets[line - 1], offset = lineOffset + column, nextLineOffset;
			if (line === linesCount) {
				if (nextLineOffset = sourceText.length, offset <= nextLineOffset) return offset;
			} else if (nextLineOffset = lineStartOffsets[line], offset < nextLineOffset) return offset;
			throw RangeError(`Column number out of range (column ${column} requested, but the length of line ${line} is ${nextLineOffset - lineOffset}).`);
		}
	}
	throw TypeError("Expected `loc` to be an object with integer `line` and `column` properties.");
}
function getNodeLoc(node) {
	lines.length === 0 && initLines();
	let loc = {
		start: getLineColumnFromOffsetUnchecked(node.start),
		end: getLineColumnFromOffsetUnchecked(node.end)
	};
	return defineProperty(node, "loc", {
		value: loc,
		writable: !0
	}), loc;
}
const { hasOwn, keys: ObjectKeys$3 } = Object, diagnostics = [];
let setupContextForFile, getInternal;
var Context = class {
	#internal;
	constructor(fullRuleName, isFixable, messages) {
		this.#internal = {
			id: fullRuleName,
			filePath: "",
			ruleIndex: -1,
			options: [],
			isFixable,
			messages
		};
	}
	get id() {
		return getInternal(this, "access `context.id`").id;
	}
	get filename() {
		return getInternal(this, "access `context.filename`").filePath;
	}
	get physicalFilename() {
		return getInternal(this, "access `context.physicalFilename`").filePath;
	}
	get options() {
		return getInternal(this, "access `context.options`").options;
	}
	get sourceCode() {
		return getInternal(this, "access `context.sourceCode`"), SOURCE_CODE;
	}
	report(diagnostic) {
		let internal = getInternal(this, "report errors"), message = getMessage(diagnostic, internal);
		if (hasOwn(diagnostic, "data")) {
			let { data } = diagnostic;
			data != null && (message = message.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
				key = key.trim();
				let value = data[key];
				return value === void 0 ? match : String(value);
			}));
		}
		let start, end, loc;
		if (hasOwn(diagnostic, "loc") && (loc = diagnostic.loc) != null) {
			if (typeof loc != "object") throw TypeError("`loc` must be an object");
			start = getOffsetFromLineColumn(loc.start), end = getOffsetFromLineColumn(loc.end);
		} else {
			let { node } = diagnostic;
			if (node == null) throw TypeError("Either `node` or `loc` is required");
			if (typeof node != "object") throw TypeError("`node` must be an object");
			let { range } = node;
			if (typeof range != "object" || !range) throw TypeError("`node.range` must be present");
			if (start = range[0], end = range[1], typeof start != "number" || typeof end != "number" || start < 0 || end < 0 || (start | 0) !== start || (end | 0) !== end) throw TypeError("`node.range[0]` and `node.range[1]` must be non-negative integers");
		}
		diagnostics.push({
			message,
			start,
			end,
			ruleIndex: internal.ruleIndex,
			fixes: getFixes(diagnostic, internal)
		});
	}
	static {
		setupContextForFile = (context, ruleIndex, filePath) => {
			let internal = context.#internal;
			internal.ruleIndex = ruleIndex, internal.filePath = filePath;
		}, getInternal = (context, actionDescription) => {
			let internal = context.#internal;
			if (internal.ruleIndex === -1) throw Error(`Cannot ${actionDescription} in \`createOnce\``);
			return internal;
		};
	}
};
function getMessage(diagnostic, internal) {
	if (hasOwn(diagnostic, "messageId")) {
		let { messageId } = diagnostic;
		if (messageId != null) return resolveMessageFromMessageId(messageId, internal);
	}
	if (hasOwn(diagnostic, "message")) {
		let { message } = diagnostic;
		if (typeof message == "string") return message;
		if (message != null) throw TypeError("`message` must be a string");
	}
	throw Error("Either `message` or `messageId` is required");
}
function resolveMessageFromMessageId(messageId, internal) {
	let { messages } = internal;
	if (messages === null) throw Error(`Cannot use messageId '${messageId}' - rule does not define any messages in \`meta.messages\``);
	if (!hasOwn(messages, messageId)) throw Error(`Unknown messageId '${messageId}'. Available \`messageIds\`: ${ObjectKeys$3(messages).map((msg) => `'${msg}'`).join(", ")}`);
	return messages[messageId];
}
const ObjectKeys$2 = Object.keys, registeredPluginPaths = /* @__PURE__ */ new Set(), registeredRules = [], neverRunBeforeHook = () => !1;
async function loadPlugin(path) {
	try {
		let res = await loadPluginImpl(path);
		return JSON.stringify({ Success: res });
	} catch (err) {
		return JSON.stringify({ Failure: getErrorMessage(err) });
	}
}
async function loadPluginImpl(path) {
	if (registeredPluginPaths.has(path)) throw Error("This plugin has already been registered. This is a bug in Oxlint. Please report it.");
	let { default: plugin } = await import(pathToFileURL(path).href);
	registeredPluginPaths.add(path);
	let pluginName = plugin.meta.name, offset = registeredRules.length, { rules } = plugin, ruleNames = ObjectKeys$2(rules), ruleNamesLen = ruleNames.length;
	for (let i = 0; i < ruleNamesLen; i++) {
		let ruleName = ruleNames[i], rule = rules[ruleName], isFixable = !1, messages = null, ruleMeta = rule.meta;
		if (ruleMeta != null) {
			if (typeof ruleMeta != "object") throw TypeError("Invalid `meta`");
			let { fixable } = ruleMeta;
			if (fixable != null) {
				if (fixable !== "code" && fixable !== "whitespace") throw TypeError("Invalid `meta.fixable`");
				isFixable = !0;
			}
			let inputMessages = ruleMeta.messages;
			if (inputMessages != null) {
				if (typeof inputMessages != "object") throw TypeError("`meta.messages` must be an object if provided");
				messages = inputMessages;
			}
		}
		let context = new Context(`${pluginName}/${ruleName}`, isFixable, messages), ruleAndContext;
		if ("createOnce" in rule) {
			let visitorWithHooks = rule.createOnce(context);
			if (typeof visitorWithHooks != "object" || !visitorWithHooks) throw TypeError("`createOnce` must return an object");
			let { before: beforeHook, after: afterHook,...visitor } = visitorWithHooks;
			beforeHook = conformHookFn(beforeHook, "before"), afterHook = conformHookFn(afterHook, "after"), ObjectKeys$2(visitor).length === 0 && (beforeHook = neverRunBeforeHook, afterHook = null), ruleAndContext = {
				rule,
				context,
				visitor,
				beforeHook,
				afterHook
			};
		} else ruleAndContext = {
			rule,
			context,
			visitor: null,
			beforeHook: null,
			afterHook: null
		};
		registeredRules.push(ruleAndContext);
	}
	return {
		name: pluginName,
		offset,
		ruleNames
	};
}
function conformHookFn(hookFn, hookName) {
	if (hookFn == null) return null;
	if (typeof hookFn != "function") throw TypeError(`\`${hookName}\` hook must be a function if provided`);
	return hookFn;
}
const NODE_TYPE_IDS_MAP = new Map([
	["DebuggerStatement", 0],
	["EmptyStatement", 1],
	["Literal", 2],
	["PrivateIdentifier", 3],
	["Super", 4],
	["TemplateElement", 5],
	["ThisExpression", 6],
	["JSXClosingFragment", 7],
	["JSXEmptyExpression", 8],
	["JSXIdentifier", 9],
	["JSXOpeningFragment", 10],
	["JSXText", 11],
	["TSAnyKeyword", 12],
	["TSBigIntKeyword", 13],
	["TSBooleanKeyword", 14],
	["TSIntrinsicKeyword", 15],
	["TSJSDocUnknownType", 16],
	["TSNeverKeyword", 17],
	["TSNullKeyword", 18],
	["TSNumberKeyword", 19],
	["TSObjectKeyword", 20],
	["TSStringKeyword", 21],
	["TSSymbolKeyword", 22],
	["TSThisType", 23],
	["TSUndefinedKeyword", 24],
	["TSUnknownKeyword", 25],
	["TSVoidKeyword", 26],
	["AccessorProperty", 27],
	["ArrayExpression", 28],
	["ArrayPattern", 29],
	["ArrowFunctionExpression", 30],
	["AssignmentExpression", 31],
	["AssignmentPattern", 32],
	["AwaitExpression", 33],
	["BinaryExpression", 34],
	["BlockStatement", 35],
	["BreakStatement", 36],
	["CallExpression", 37],
	["CatchClause", 38],
	["ChainExpression", 39],
	["ClassBody", 40],
	["ClassDeclaration", 41],
	["ClassExpression", 42],
	["ConditionalExpression", 43],
	["ContinueStatement", 44],
	["Decorator", 45],
	["DoWhileStatement", 46],
	["ExportAllDeclaration", 47],
	["ExportDefaultDeclaration", 48],
	["ExportNamedDeclaration", 49],
	["ExportSpecifier", 50],
	["ExpressionStatement", 51],
	["ForInStatement", 52],
	["ForOfStatement", 53],
	["ForStatement", 54],
	["FunctionDeclaration", 55],
	["FunctionExpression", 56],
	["Identifier", 57],
	["IfStatement", 58],
	["ImportAttribute", 59],
	["ImportDeclaration", 60],
	["ImportDefaultSpecifier", 61],
	["ImportExpression", 62],
	["ImportNamespaceSpecifier", 63],
	["ImportSpecifier", 64],
	["LabeledStatement", 65],
	["LogicalExpression", 66],
	["MemberExpression", 67],
	["MetaProperty", 68],
	["MethodDefinition", 69],
	["NewExpression", 70],
	["ObjectExpression", 71],
	["ObjectPattern", 72],
	["ParenthesizedExpression", 73],
	["Program", 74],
	["Property", 75],
	["PropertyDefinition", 76],
	["RestElement", 77],
	["ReturnStatement", 78],
	["SequenceExpression", 79],
	["SpreadElement", 80],
	["StaticBlock", 81],
	["SwitchCase", 82],
	["SwitchStatement", 83],
	["TaggedTemplateExpression", 84],
	["TemplateLiteral", 85],
	["ThrowStatement", 86],
	["TryStatement", 87],
	["UnaryExpression", 88],
	["UpdateExpression", 89],
	["V8IntrinsicExpression", 90],
	["VariableDeclaration", 91],
	["VariableDeclarator", 92],
	["WhileStatement", 93],
	["WithStatement", 94],
	["YieldExpression", 95],
	["JSXAttribute", 96],
	["JSXClosingElement", 97],
	["JSXElement", 98],
	["JSXExpressionContainer", 99],
	["JSXFragment", 100],
	["JSXMemberExpression", 101],
	["JSXNamespacedName", 102],
	["JSXOpeningElement", 103],
	["JSXSpreadAttribute", 104],
	["JSXSpreadChild", 105],
	["TSAbstractAccessorProperty", 106],
	["TSAbstractMethodDefinition", 107],
	["TSAbstractPropertyDefinition", 108],
	["TSArrayType", 109],
	["TSAsExpression", 110],
	["TSCallSignatureDeclaration", 111],
	["TSClassImplements", 112],
	["TSConditionalType", 113],
	["TSConstructSignatureDeclaration", 114],
	["TSConstructorType", 115],
	["TSDeclareFunction", 116],
	["TSEmptyBodyFunctionExpression", 117],
	["TSEnumBody", 118],
	["TSEnumDeclaration", 119],
	["TSEnumMember", 120],
	["TSExportAssignment", 121],
	["TSExternalModuleReference", 122],
	["TSFunctionType", 123],
	["TSImportEqualsDeclaration", 124],
	["TSImportType", 125],
	["TSIndexSignature", 126],
	["TSIndexedAccessType", 127],
	["TSInferType", 128],
	["TSInstantiationExpression", 129],
	["TSInterfaceBody", 130],
	["TSInterfaceDeclaration", 131],
	["TSInterfaceHeritage", 132],
	["TSIntersectionType", 133],
	["TSJSDocNonNullableType", 134],
	["TSJSDocNullableType", 135],
	["TSLiteralType", 136],
	["TSMappedType", 137],
	["TSMethodSignature", 138],
	["TSModuleBlock", 139],
	["TSModuleDeclaration", 140],
	["TSNamedTupleMember", 141],
	["TSNamespaceExportDeclaration", 142],
	["TSNonNullExpression", 143],
	["TSOptionalType", 144],
	["TSParameterProperty", 145],
	["TSParenthesizedType", 146],
	["TSPropertySignature", 147],
	["TSQualifiedName", 148],
	["TSRestType", 149],
	["TSSatisfiesExpression", 150],
	["TSTemplateLiteralType", 151],
	["TSTupleType", 152],
	["TSTypeAliasDeclaration", 153],
	["TSTypeAnnotation", 154],
	["TSTypeAssertion", 155],
	["TSTypeLiteral", 156],
	["TSTypeOperator", 157],
	["TSTypeParameter", 158],
	["TSTypeParameterDeclaration", 159],
	["TSTypeParameterInstantiation", 160],
	["TSTypePredicate", 161],
	["TSTypeQuery", 162],
	["TSTypeReference", 163],
	["TSUnionType", 164]
]), FUNCTION_NODE_TYPE_IDS = [
	30,
	55,
	56
];
var import_esquery_min = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(e, t) {
		typeof exports == "object" && module !== void 0 ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e ||= self).esquery = t();
	})(exports, (function() {
		function e(t$1) {
			return (e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e$1) {
				return typeof e$1;
			} : function(e$1) {
				return e$1 && typeof Symbol == "function" && e$1.constructor === Symbol && e$1 !== Symbol.prototype ? "symbol" : typeof e$1;
			})(t$1);
		}
		function t(e$1, t$1) {
			return function(e$2) {
				if (Array.isArray(e$2)) return e$2;
			}(e$1) || function(e$2, t$2) {
				var r$1 = e$2 == null ? null : typeof Symbol < "u" && e$2[Symbol.iterator] || e$2["@@iterator"];
				if (r$1 != null) {
					var n$1, o$1, a$1, i$1, s$1 = [], u$1 = !0, l$1 = !1;
					try {
						if (a$1 = (r$1 = r$1.call(e$2)).next, t$2 === 0) {
							if (Object(r$1) !== r$1) return;
							u$1 = !1;
						} else for (; !(u$1 = (n$1 = a$1.call(r$1)).done) && (s$1.push(n$1.value), s$1.length !== t$2); u$1 = !0);
					} catch (e$3) {
						l$1 = !0, o$1 = e$3;
					} finally {
						try {
							if (!u$1 && r$1.return != null && (i$1 = r$1.return(), Object(i$1) !== i$1)) return;
						} finally {
							if (l$1) throw o$1;
						}
					}
					return s$1;
				}
			}(e$1, t$1) || n(e$1, t$1) || function() {
				throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}();
		}
		function r(e$1) {
			return function(e$2) {
				if (Array.isArray(e$2)) return o(e$2);
			}(e$1) || function(e$2) {
				if (typeof Symbol < "u" && e$2[Symbol.iterator] != null || e$2["@@iterator"] != null) return Array.from(e$2);
			}(e$1) || n(e$1) || function() {
				throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}();
		}
		function n(e$1, t$1) {
			if (e$1) {
				if (typeof e$1 == "string") return o(e$1, t$1);
				var r$1 = Object.prototype.toString.call(e$1).slice(8, -1);
				return r$1 === "Object" && e$1.constructor && (r$1 = e$1.constructor.name), r$1 === "Map" || r$1 === "Set" ? Array.from(e$1) : r$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r$1) ? o(e$1, t$1) : void 0;
			}
		}
		function o(e$1, t$1) {
			(t$1 == null || t$1 > e$1.length) && (t$1 = e$1.length);
			for (var r$1 = 0, n$1 = Array(t$1); r$1 < t$1; r$1++) n$1[r$1] = e$1[r$1];
			return n$1;
		}
		function a(e$1, t$1) {
			return e$1(t$1 = { exports: {} }, t$1.exports), t$1.exports;
		}
		var i = a((function(e$1, t$1) {
			(function e$2(t$2) {
				var r$1, n$1, o$1, a$1, i$1, s$1;
				function u$1(e$3) {
					var t$3, r$2, n$2 = {};
					for (t$3 in e$3) e$3.hasOwnProperty(t$3) && (r$2 = e$3[t$3], n$2[t$3] = typeof r$2 == "object" && r$2 ? u$1(r$2) : r$2);
					return n$2;
				}
				function l$1(e$3, t$3) {
					this.parent = e$3, this.key = t$3;
				}
				function c$1(e$3, t$3, r$2, n$2) {
					this.node = e$3, this.path = t$3, this.wrap = r$2, this.ref = n$2;
				}
				function f$1() {}
				function p$1(e$3) {
					return typeof e$3 == "object" && !!e$3 && typeof e$3.type == "string";
				}
				function h$1(e$3, t$3) {
					return (e$3 === r$1.ObjectExpression || e$3 === r$1.ObjectPattern) && t$3 === "properties";
				}
				function y$1(e$3, t$3) {
					for (var r$2 = e$3.length - 1; r$2 >= 0; --r$2) if (e$3[r$2].node === t$3) return !0;
					return !1;
				}
				function d$1(e$3, t$3) {
					return new f$1().traverse(e$3, t$3);
				}
				function m$1(e$3, t$3) {
					var r$2;
					return r$2 = function(e$4, t$4) {
						var r$3, n$2, o$2, a$2;
						for (n$2 = e$4.length, o$2 = 0; n$2;) t$4(e$4[a$2 = o$2 + (r$3 = n$2 >>> 1)]) ? n$2 = r$3 : (o$2 = a$2 + 1, n$2 -= r$3 + 1);
						return o$2;
					}(t$3, (function(t$4) {
						return t$4.range[0] > e$3.range[0];
					})), e$3.extendedRange = [e$3.range[0], e$3.range[1]], r$2 !== t$3.length && (e$3.extendedRange[1] = t$3[r$2].range[0]), --r$2 >= 0 && (e$3.extendedRange[0] = t$3[r$2].range[1]), e$3;
				}
				return r$1 = {
					AssignmentExpression: "AssignmentExpression",
					AssignmentPattern: "AssignmentPattern",
					ArrayExpression: "ArrayExpression",
					ArrayPattern: "ArrayPattern",
					ArrowFunctionExpression: "ArrowFunctionExpression",
					AwaitExpression: "AwaitExpression",
					BlockStatement: "BlockStatement",
					BinaryExpression: "BinaryExpression",
					BreakStatement: "BreakStatement",
					CallExpression: "CallExpression",
					CatchClause: "CatchClause",
					ChainExpression: "ChainExpression",
					ClassBody: "ClassBody",
					ClassDeclaration: "ClassDeclaration",
					ClassExpression: "ClassExpression",
					ComprehensionBlock: "ComprehensionBlock",
					ComprehensionExpression: "ComprehensionExpression",
					ConditionalExpression: "ConditionalExpression",
					ContinueStatement: "ContinueStatement",
					DebuggerStatement: "DebuggerStatement",
					DirectiveStatement: "DirectiveStatement",
					DoWhileStatement: "DoWhileStatement",
					EmptyStatement: "EmptyStatement",
					ExportAllDeclaration: "ExportAllDeclaration",
					ExportDefaultDeclaration: "ExportDefaultDeclaration",
					ExportNamedDeclaration: "ExportNamedDeclaration",
					ExportSpecifier: "ExportSpecifier",
					ExpressionStatement: "ExpressionStatement",
					ForStatement: "ForStatement",
					ForInStatement: "ForInStatement",
					ForOfStatement: "ForOfStatement",
					FunctionDeclaration: "FunctionDeclaration",
					FunctionExpression: "FunctionExpression",
					GeneratorExpression: "GeneratorExpression",
					Identifier: "Identifier",
					IfStatement: "IfStatement",
					ImportExpression: "ImportExpression",
					ImportDeclaration: "ImportDeclaration",
					ImportDefaultSpecifier: "ImportDefaultSpecifier",
					ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
					ImportSpecifier: "ImportSpecifier",
					Literal: "Literal",
					LabeledStatement: "LabeledStatement",
					LogicalExpression: "LogicalExpression",
					MemberExpression: "MemberExpression",
					MetaProperty: "MetaProperty",
					MethodDefinition: "MethodDefinition",
					ModuleSpecifier: "ModuleSpecifier",
					NewExpression: "NewExpression",
					ObjectExpression: "ObjectExpression",
					ObjectPattern: "ObjectPattern",
					PrivateIdentifier: "PrivateIdentifier",
					Program: "Program",
					Property: "Property",
					PropertyDefinition: "PropertyDefinition",
					RestElement: "RestElement",
					ReturnStatement: "ReturnStatement",
					SequenceExpression: "SequenceExpression",
					SpreadElement: "SpreadElement",
					Super: "Super",
					SwitchStatement: "SwitchStatement",
					SwitchCase: "SwitchCase",
					TaggedTemplateExpression: "TaggedTemplateExpression",
					TemplateElement: "TemplateElement",
					TemplateLiteral: "TemplateLiteral",
					ThisExpression: "ThisExpression",
					ThrowStatement: "ThrowStatement",
					TryStatement: "TryStatement",
					UnaryExpression: "UnaryExpression",
					UpdateExpression: "UpdateExpression",
					VariableDeclaration: "VariableDeclaration",
					VariableDeclarator: "VariableDeclarator",
					WhileStatement: "WhileStatement",
					WithStatement: "WithStatement",
					YieldExpression: "YieldExpression"
				}, o$1 = {
					AssignmentExpression: ["left", "right"],
					AssignmentPattern: ["left", "right"],
					ArrayExpression: ["elements"],
					ArrayPattern: ["elements"],
					ArrowFunctionExpression: ["params", "body"],
					AwaitExpression: ["argument"],
					BlockStatement: ["body"],
					BinaryExpression: ["left", "right"],
					BreakStatement: ["label"],
					CallExpression: ["callee", "arguments"],
					CatchClause: ["param", "body"],
					ChainExpression: ["expression"],
					ClassBody: ["body"],
					ClassDeclaration: [
						"id",
						"superClass",
						"body"
					],
					ClassExpression: [
						"id",
						"superClass",
						"body"
					],
					ComprehensionBlock: ["left", "right"],
					ComprehensionExpression: [
						"blocks",
						"filter",
						"body"
					],
					ConditionalExpression: [
						"test",
						"consequent",
						"alternate"
					],
					ContinueStatement: ["label"],
					DebuggerStatement: [],
					DirectiveStatement: [],
					DoWhileStatement: ["body", "test"],
					EmptyStatement: [],
					ExportAllDeclaration: ["source"],
					ExportDefaultDeclaration: ["declaration"],
					ExportNamedDeclaration: [
						"declaration",
						"specifiers",
						"source"
					],
					ExportSpecifier: ["exported", "local"],
					ExpressionStatement: ["expression"],
					ForStatement: [
						"init",
						"test",
						"update",
						"body"
					],
					ForInStatement: [
						"left",
						"right",
						"body"
					],
					ForOfStatement: [
						"left",
						"right",
						"body"
					],
					FunctionDeclaration: [
						"id",
						"params",
						"body"
					],
					FunctionExpression: [
						"id",
						"params",
						"body"
					],
					GeneratorExpression: [
						"blocks",
						"filter",
						"body"
					],
					Identifier: [],
					IfStatement: [
						"test",
						"consequent",
						"alternate"
					],
					ImportExpression: ["source"],
					ImportDeclaration: ["specifiers", "source"],
					ImportDefaultSpecifier: ["local"],
					ImportNamespaceSpecifier: ["local"],
					ImportSpecifier: ["imported", "local"],
					Literal: [],
					LabeledStatement: ["label", "body"],
					LogicalExpression: ["left", "right"],
					MemberExpression: ["object", "property"],
					MetaProperty: ["meta", "property"],
					MethodDefinition: ["key", "value"],
					ModuleSpecifier: [],
					NewExpression: ["callee", "arguments"],
					ObjectExpression: ["properties"],
					ObjectPattern: ["properties"],
					PrivateIdentifier: [],
					Program: ["body"],
					Property: ["key", "value"],
					PropertyDefinition: ["key", "value"],
					RestElement: ["argument"],
					ReturnStatement: ["argument"],
					SequenceExpression: ["expressions"],
					SpreadElement: ["argument"],
					Super: [],
					SwitchStatement: ["discriminant", "cases"],
					SwitchCase: ["test", "consequent"],
					TaggedTemplateExpression: ["tag", "quasi"],
					TemplateElement: [],
					TemplateLiteral: ["quasis", "expressions"],
					ThisExpression: [],
					ThrowStatement: ["argument"],
					TryStatement: [
						"block",
						"handler",
						"finalizer"
					],
					UnaryExpression: ["argument"],
					UpdateExpression: ["argument"],
					VariableDeclaration: ["declarations"],
					VariableDeclarator: ["id", "init"],
					WhileStatement: ["test", "body"],
					WithStatement: ["object", "body"],
					YieldExpression: ["argument"]
				}, n$1 = {
					Break: a$1 = {},
					Skip: i$1 = {},
					Remove: s$1 = {}
				}, l$1.prototype.replace = function(e$3) {
					this.parent[this.key] = e$3;
				}, l$1.prototype.remove = function() {
					return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
				}, f$1.prototype.path = function() {
					var e$3, t$3, r$2, n$2, o$2;
					function a$2(e$4, t$4) {
						if (Array.isArray(t$4)) for (r$2 = 0, n$2 = t$4.length; r$2 < n$2; ++r$2) e$4.push(t$4[r$2]);
						else e$4.push(t$4);
					}
					if (!this.__current.path) return null;
					for (o$2 = [], e$3 = 2, t$3 = this.__leavelist.length; e$3 < t$3; ++e$3) a$2(o$2, this.__leavelist[e$3].path);
					return a$2(o$2, this.__current.path), o$2;
				}, f$1.prototype.type = function() {
					return this.current().type || this.__current.wrap;
				}, f$1.prototype.parents = function() {
					var e$3, t$3, r$2;
					for (r$2 = [], e$3 = 1, t$3 = this.__leavelist.length; e$3 < t$3; ++e$3) r$2.push(this.__leavelist[e$3].node);
					return r$2;
				}, f$1.prototype.current = function() {
					return this.__current.node;
				}, f$1.prototype.__execute = function(e$3, t$3) {
					var r$2, n$2;
					return n$2 = void 0, r$2 = this.__current, this.__current = t$3, this.__state = null, e$3 && (n$2 = e$3.call(this, t$3.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r$2, n$2;
				}, f$1.prototype.notify = function(e$3) {
					this.__state = e$3;
				}, f$1.prototype.skip = function() {
					this.notify(i$1);
				}, f$1.prototype.break = function() {
					this.notify(a$1);
				}, f$1.prototype.remove = function() {
					this.notify(s$1);
				}, f$1.prototype.__initialize = function(e$3, t$3) {
					this.visitor = t$3, this.root = e$3, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, t$3.fallback === "iteration" ? this.__fallback = Object.keys : typeof t$3.fallback == "function" && (this.__fallback = t$3.fallback), this.__keys = o$1, t$3.keys && (this.__keys = Object.assign(Object.create(this.__keys), t$3.keys));
				}, f$1.prototype.traverse = function(e$3, t$3) {
					var r$2, n$2, o$2, s$2, u$2, l$2, f$2, d$2, m$2, x$1, v$1, g$1;
					for (this.__initialize(e$3, t$3), g$1 = {}, r$2 = this.__worklist, n$2 = this.__leavelist, r$2.push(new c$1(e$3, null, null, null)), n$2.push(new c$1(null, null, null, null)); r$2.length;) if ((o$2 = r$2.pop()) !== g$1) {
						if (o$2.node) {
							if (l$2 = this.__execute(t$3.enter, o$2), this.__state === a$1 || l$2 === a$1) return;
							if (r$2.push(g$1), n$2.push(o$2), this.__state === i$1 || l$2 === i$1) continue;
							if (u$2 = (s$2 = o$2.node).type || o$2.wrap, !(x$1 = this.__keys[u$2])) {
								if (!this.__fallback) throw Error("Unknown node type " + u$2 + ".");
								x$1 = this.__fallback(s$2);
							}
							for (d$2 = x$1.length; --d$2 >= 0;) if (v$1 = s$2[f$2 = x$1[d$2]]) {
								if (Array.isArray(v$1)) {
									for (m$2 = v$1.length; --m$2 >= 0;) if (v$1[m$2] && !y$1(n$2, v$1[m$2])) {
										if (h$1(u$2, x$1[d$2])) o$2 = new c$1(v$1[m$2], [f$2, m$2], "Property", null);
										else {
											if (!p$1(v$1[m$2])) continue;
											o$2 = new c$1(v$1[m$2], [f$2, m$2], null, null);
										}
										r$2.push(o$2);
									}
								} else if (p$1(v$1)) {
									if (y$1(n$2, v$1)) continue;
									r$2.push(new c$1(v$1, f$2, null, null));
								}
							}
						}
					} else if (o$2 = n$2.pop(), l$2 = this.__execute(t$3.leave, o$2), this.__state === a$1 || l$2 === a$1) return;
				}, f$1.prototype.replace = function(e$3, t$3) {
					var r$2, n$2, o$2, u$2, f$2, y$2, d$2, m$2, x$1, v$1, g$1, A$1, E;
					function b(e$4) {
						var t$4, n$3, o$3, a$2;
						if (e$4.ref.remove()) {
							for (n$3 = e$4.ref.key, a$2 = e$4.ref.parent, t$4 = r$2.length; t$4--;) if ((o$3 = r$2[t$4]).ref && o$3.ref.parent === a$2) {
								if (o$3.ref.key < n$3) break;
								--o$3.ref.key;
							}
						}
					}
					for (this.__initialize(e$3, t$3), g$1 = {}, r$2 = this.__worklist, n$2 = this.__leavelist, y$2 = new c$1(e$3, null, null, new l$1(A$1 = { root: e$3 }, "root")), r$2.push(y$2), n$2.push(y$2); r$2.length;) if ((y$2 = r$2.pop()) !== g$1) {
						if ((f$2 = this.__execute(t$3.enter, y$2)) !== void 0 && f$2 !== a$1 && f$2 !== i$1 && f$2 !== s$1 && (y$2.ref.replace(f$2), y$2.node = f$2), this.__state !== s$1 && f$2 !== s$1 || (b(y$2), y$2.node = null), this.__state === a$1 || f$2 === a$1) return A$1.root;
						if ((o$2 = y$2.node) && (r$2.push(g$1), n$2.push(y$2), this.__state !== i$1 && f$2 !== i$1)) {
							if (u$2 = o$2.type || y$2.wrap, !(x$1 = this.__keys[u$2])) {
								if (!this.__fallback) throw Error("Unknown node type " + u$2 + ".");
								x$1 = this.__fallback(o$2);
							}
							for (d$2 = x$1.length; --d$2 >= 0;) if (v$1 = o$2[E = x$1[d$2]]) if (Array.isArray(v$1)) {
								for (m$2 = v$1.length; --m$2 >= 0;) if (v$1[m$2]) {
									if (h$1(u$2, x$1[d$2])) y$2 = new c$1(v$1[m$2], [E, m$2], "Property", new l$1(v$1, m$2));
									else {
										if (!p$1(v$1[m$2])) continue;
										y$2 = new c$1(v$1[m$2], [E, m$2], null, new l$1(v$1, m$2));
									}
									r$2.push(y$2);
								}
							} else p$1(v$1) && r$2.push(new c$1(v$1, E, null, new l$1(o$2, E)));
						}
					} else if (y$2 = n$2.pop(), (f$2 = this.__execute(t$3.leave, y$2)) !== void 0 && f$2 !== a$1 && f$2 !== i$1 && f$2 !== s$1 && y$2.ref.replace(f$2), this.__state !== s$1 && f$2 !== s$1 || b(y$2), this.__state === a$1 || f$2 === a$1) return A$1.root;
					return A$1.root;
				}, t$2.Syntax = r$1, t$2.traverse = d$1, t$2.replace = function(e$3, t$3) {
					return new f$1().replace(e$3, t$3);
				}, t$2.attachComments = function(e$3, t$3, r$2) {
					var o$2, a$2, i$2, s$2, l$2 = [];
					if (!e$3.range) throw Error("attachComments needs range information");
					if (!r$2.length) {
						if (t$3.length) {
							for (i$2 = 0, a$2 = t$3.length; i$2 < a$2; i$2 += 1) (o$2 = u$1(t$3[i$2])).extendedRange = [0, e$3.range[0]], l$2.push(o$2);
							e$3.leadingComments = l$2;
						}
						return e$3;
					}
					for (i$2 = 0, a$2 = t$3.length; i$2 < a$2; i$2 += 1) l$2.push(m$1(u$1(t$3[i$2]), r$2));
					return s$2 = 0, d$1(e$3, { enter: function(e$4) {
						for (var t$4; s$2 < l$2.length && !((t$4 = l$2[s$2]).extendedRange[1] > e$4.range[0]);) t$4.extendedRange[1] === e$4.range[0] ? (e$4.leadingComments ||= [], e$4.leadingComments.push(t$4), l$2.splice(s$2, 1)) : s$2 += 1;
						return s$2 === l$2.length ? n$1.Break : l$2[s$2].extendedRange[0] > e$4.range[1] ? n$1.Skip : void 0;
					} }), s$2 = 0, d$1(e$3, { leave: function(e$4) {
						for (var t$4; s$2 < l$2.length && (t$4 = l$2[s$2], !(e$4.range[1] < t$4.extendedRange[0]));) e$4.range[1] === t$4.extendedRange[0] ? (e$4.trailingComments ||= [], e$4.trailingComments.push(t$4), l$2.splice(s$2, 1)) : s$2 += 1;
						return s$2 === l$2.length ? n$1.Break : l$2[s$2].extendedRange[0] > e$4.range[1] ? n$1.Skip : void 0;
					} }), e$3;
				}, t$2.VisitorKeys = o$1, t$2.VisitorOption = n$1, t$2.Controller = f$1, t$2.cloneEnvironment = function() {
					return e$2({});
				}, t$2;
			})(t$1);
		})), s = a((function(e$1) {
			e$1.exports &&= function() {
				function e$2(t$1, r$1, n$1, o$1) {
					this.message = t$1, this.expected = r$1, this.found = n$1, this.location = o$1, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, e$2);
				}
				return function(e$3, t$1) {
					function r$1() {
						this.constructor = e$3;
					}
					r$1.prototype = t$1.prototype, e$3.prototype = new r$1();
				}(e$2, Error), e$2.buildMessage = function(e$3, t$1) {
					var r$1 = {
						literal: function(e$4) {
							return "\"" + o$1(e$4.text) + "\"";
						},
						class: function(e$4) {
							var t$2, r$2 = "";
							for (t$2 = 0; t$2 < e$4.parts.length; t$2++) r$2 += e$4.parts[t$2] instanceof Array ? a$1(e$4.parts[t$2][0]) + "-" + a$1(e$4.parts[t$2][1]) : a$1(e$4.parts[t$2]);
							return "[" + (e$4.inverted ? "^" : "") + r$2 + "]";
						},
						any: function(e$4) {
							return "any character";
						},
						end: function(e$4) {
							return "end of input";
						},
						other: function(e$4) {
							return e$4.description;
						}
					};
					function n$1(e$4) {
						return e$4.charCodeAt(0).toString(16).toUpperCase();
					}
					function o$1(e$4) {
						return e$4.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (function(e$5) {
							return "\\x0" + n$1(e$5);
						})).replace(/[\x10-\x1F\x7F-\x9F]/g, (function(e$5) {
							return "\\x" + n$1(e$5);
						}));
					}
					function a$1(e$4) {
						return e$4.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (function(e$5) {
							return "\\x0" + n$1(e$5);
						})).replace(/[\x10-\x1F\x7F-\x9F]/g, (function(e$5) {
							return "\\x" + n$1(e$5);
						}));
					}
					return "Expected " + function(e$4) {
						var t$2, n$2, o$2, a$2 = Array(e$4.length);
						for (t$2 = 0; t$2 < e$4.length; t$2++) a$2[t$2] = (o$2 = e$4[t$2], r$1[o$2.type](o$2));
						if (a$2.sort(), a$2.length > 0) {
							for (t$2 = 1, n$2 = 1; t$2 < a$2.length; t$2++) a$2[t$2 - 1] !== a$2[t$2] && (a$2[n$2] = a$2[t$2], n$2++);
							a$2.length = n$2;
						}
						switch (a$2.length) {
							case 1: return a$2[0];
							case 2: return a$2[0] + " or " + a$2[1];
							default: return a$2.slice(0, -1).join(", ") + ", or " + a$2[a$2.length - 1];
						}
					}(e$3) + " but " + function(e$4) {
						return e$4 ? "\"" + o$1(e$4) + "\"" : "end of input";
					}(t$1) + " found.";
				}, {
					SyntaxError: e$2,
					parse: function(t$1, r$1) {
						r$1 = r$1 === void 0 ? {} : r$1;
						var n$1, o$1, a$1, i$1, s$1 = {}, u$1 = { start: me }, l$1 = me, c$1 = fe(" ", !1), f$1 = /^[^ [\],():#!=><~+.]/, p$1 = pe([
							" ",
							"[",
							"]",
							",",
							"(",
							")",
							":",
							"#",
							"!",
							"=",
							">",
							"<",
							"~",
							"+",
							"."
						], !0, !1), h$1 = fe(">", !1), y$1 = fe("~", !1), d$1 = fe("+", !1), m$1 = fe(",", !1), x$1 = function(e$3, t$2) {
							return [e$3].concat(t$2.map((function(e$4) {
								return e$4[3];
							})));
						}, v$1 = fe("!", !1), g$1 = fe("*", !1), A$1 = fe("#", !1), E = fe("[", !1), b = fe("]", !1), S = /^[><!]/, _ = pe([
							">",
							"<",
							"!"
						], !1, !1), C = fe("=", !1), w = function(e$3) {
							return (e$3 || "") + "=";
						}, P = /^[><]/, k = pe([">", "<"], !1, !1), D = fe(".", !1), I = function(e$3, t$2, r$2) {
							return {
								type: "attribute",
								name: e$3,
								operator: t$2,
								value: r$2
							};
						}, j = fe("\"", !1), T = /^[^\\"]/, F = pe(["\\", "\""], !0, !1), R = fe("\\", !1), O = { type: "any" }, L = function(e$3, t$2) {
							return e$3 + t$2;
						}, M = function(e$3) {
							return {
								type: "literal",
								value: (t$2 = e$3.join(""), t$2.replace(/\\(.)/g, (function(e$4, t$3) {
									switch (t$3) {
										case "b": return "\b";
										case "f": return "\f";
										case "n": return "\n";
										case "r": return "\r";
										case "t": return "	";
										case "v": return "\v";
										default: return t$3;
									}
								})))
							};
							var t$2;
						}, B = fe("'", !1), U = /^[^\\']/, K = pe(["\\", "'"], !0, !1), N = /^[0-9]/, W = pe([["0", "9"]], !1, !1), q = fe("type(", !1), V = /^[^ )]/, G = pe([" ", ")"], !0, !1), z = fe(")", !1), H = /^[imsu]/, Y = pe([
							"i",
							"m",
							"s",
							"u"
						], !1, !1), $ = fe("/", !1), J = /^[^\/]/, Q = pe(["/"], !0, !1), X = fe(":not(", !1), Z = fe(":matches(", !1), ee = fe(":has(", !1), te = fe(":first-child", !1), re = fe(":last-child", !1), ne = fe(":nth-child(", !1), oe = fe(":nth-last-child(", !1), ae = fe(":", !1), ie = 0, se = [{
							line: 1,
							column: 1
						}], ue = 0, le = [], ce = {};
						if ("startRule" in r$1) {
							if (!(r$1.startRule in u$1)) throw Error("Can't start parsing from rule \"" + r$1.startRule + "\".");
							l$1 = u$1[r$1.startRule];
						}
						function fe(e$3, t$2) {
							return {
								type: "literal",
								text: e$3,
								ignoreCase: t$2
							};
						}
						function pe(e$3, t$2, r$2) {
							return {
								type: "class",
								parts: e$3,
								inverted: t$2,
								ignoreCase: r$2
							};
						}
						function he(e$3) {
							var r$2, n$2 = se[e$3];
							if (n$2) return n$2;
							for (r$2 = e$3 - 1; !se[r$2];) r$2--;
							for (n$2 = {
								line: (n$2 = se[r$2]).line,
								column: n$2.column
							}; r$2 < e$3;) t$1.charCodeAt(r$2) === 10 ? (n$2.line++, n$2.column = 1) : n$2.column++, r$2++;
							return se[e$3] = n$2, n$2;
						}
						function ye(e$3, t$2) {
							var r$2 = he(e$3), n$2 = he(t$2);
							return {
								start: {
									offset: e$3,
									line: r$2.line,
									column: r$2.column
								},
								end: {
									offset: t$2,
									line: n$2.line,
									column: n$2.column
								}
							};
						}
						function de(e$3) {
							ie < ue || (ie > ue && (ue = ie, le = []), le.push(e$3));
						}
						function me() {
							var e$3, t$2, r$2, n$2, o$2 = 32 * ie + 0, a$2 = ce[o$2];
							return a$2 ? (ie = a$2.nextPos, a$2.result) : (e$3 = ie, (t$2 = xe()) !== s$1 && (r$2 = Ae()) !== s$1 && xe() !== s$1 ? e$3 = t$2 = (n$2 = r$2).length === 1 ? n$2[0] : {
								type: "matches",
								selectors: n$2
							} : (ie = e$3, e$3 = s$1), e$3 === s$1 && (e$3 = ie, (t$2 = xe()) !== s$1 && (t$2 = void 0), e$3 = t$2), ce[o$2] = {
								nextPos: ie,
								result: e$3
							}, e$3);
						}
						function xe() {
							var e$3, r$2, n$2 = 32 * ie + 1, o$2 = ce[n$2];
							if (o$2) return ie = o$2.nextPos, o$2.result;
							for (e$3 = [], t$1.charCodeAt(ie) === 32 ? (r$2 = " ", ie++) : (r$2 = s$1, de(c$1)); r$2 !== s$1;) e$3.push(r$2), t$1.charCodeAt(ie) === 32 ? (r$2 = " ", ie++) : (r$2 = s$1, de(c$1));
							return ce[n$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function ve() {
							var e$3, r$2, n$2, o$2 = 32 * ie + 2, a$2 = ce[o$2];
							if (a$2) return ie = a$2.nextPos, a$2.result;
							if (r$2 = [], f$1.test(t$1.charAt(ie)) ? (n$2 = t$1.charAt(ie), ie++) : (n$2 = s$1, de(p$1)), n$2 !== s$1) for (; n$2 !== s$1;) r$2.push(n$2), f$1.test(t$1.charAt(ie)) ? (n$2 = t$1.charAt(ie), ie++) : (n$2 = s$1, de(p$1));
							else r$2 = s$1;
							return r$2 !== s$1 && (r$2 = r$2.join("")), e$3 = r$2, ce[o$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function ge() {
							var e$3, r$2, n$2, o$2 = 32 * ie + 3, a$2 = ce[o$2];
							return a$2 ? (ie = a$2.nextPos, a$2.result) : (e$3 = ie, (r$2 = xe()) === s$1 ? (ie = e$3, e$3 = s$1) : (t$1.charCodeAt(ie) === 62 ? (n$2 = ">", ie++) : (n$2 = s$1, de(h$1)), n$2 !== s$1 && xe() !== s$1 ? e$3 = r$2 = "child" : (ie = e$3, e$3 = s$1)), e$3 === s$1 && (e$3 = ie, (r$2 = xe()) === s$1 ? (ie = e$3, e$3 = s$1) : (t$1.charCodeAt(ie) === 126 ? (n$2 = "~", ie++) : (n$2 = s$1, de(y$1)), n$2 !== s$1 && xe() !== s$1 ? e$3 = r$2 = "sibling" : (ie = e$3, e$3 = s$1)), e$3 === s$1 && (e$3 = ie, (r$2 = xe()) === s$1 ? (ie = e$3, e$3 = s$1) : (t$1.charCodeAt(ie) === 43 ? (n$2 = "+", ie++) : (n$2 = s$1, de(d$1)), n$2 !== s$1 && xe() !== s$1 ? e$3 = r$2 = "adjacent" : (ie = e$3, e$3 = s$1)), e$3 === s$1 && (e$3 = ie, t$1.charCodeAt(ie) === 32 ? (r$2 = " ", ie++) : (r$2 = s$1, de(c$1)), r$2 !== s$1 && (n$2 = xe()) !== s$1 ? e$3 = r$2 = "descendant" : (ie = e$3, e$3 = s$1)))), ce[o$2] = {
								nextPos: ie,
								result: e$3
							}, e$3);
						}
						function Ae() {
							var e$3, r$2, n$2, o$2, a$2, i$2, u$2, l$2, c$2 = 32 * ie + 5, f$2 = ce[c$2];
							if (f$2) return ie = f$2.nextPos, f$2.result;
							if (e$3 = ie, (r$2 = be()) !== s$1) {
								for (n$2 = [], o$2 = ie, (a$2 = xe()) === s$1 ? (ie = o$2, o$2 = s$1) : (t$1.charCodeAt(ie) === 44 ? (i$2 = ",", ie++) : (i$2 = s$1, de(m$1)), i$2 !== s$1 && (u$2 = xe()) !== s$1 && (l$2 = be()) !== s$1 ? o$2 = a$2 = [
									a$2,
									i$2,
									u$2,
									l$2
								] : (ie = o$2, o$2 = s$1)); o$2 !== s$1;) n$2.push(o$2), o$2 = ie, (a$2 = xe()) === s$1 ? (ie = o$2, o$2 = s$1) : (t$1.charCodeAt(ie) === 44 ? (i$2 = ",", ie++) : (i$2 = s$1, de(m$1)), i$2 !== s$1 && (u$2 = xe()) !== s$1 && (l$2 = be()) !== s$1 ? o$2 = a$2 = [
									a$2,
									i$2,
									u$2,
									l$2
								] : (ie = o$2, o$2 = s$1));
								n$2 === s$1 ? (ie = e$3, e$3 = s$1) : e$3 = r$2 = x$1(r$2, n$2);
							} else ie = e$3, e$3 = s$1;
							return ce[c$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function Ee() {
							var e$3, t$2, r$2, n$2, o$2, a$2 = 32 * ie + 6, i$2 = ce[a$2];
							return i$2 ? (ie = i$2.nextPos, i$2.result) : (e$3 = ie, (t$2 = ge()) === s$1 && (t$2 = null), t$2 !== s$1 && (r$2 = be()) !== s$1 ? (o$2 = r$2, e$3 = t$2 = (n$2 = t$2) ? {
								type: n$2,
								left: { type: "exactNode" },
								right: o$2
							} : o$2) : (ie = e$3, e$3 = s$1), ce[a$2] = {
								nextPos: ie,
								result: e$3
							}, e$3);
						}
						function be() {
							var e$3, t$2, r$2, n$2, o$2, a$2, i$2, u$2 = 32 * ie + 7, l$2 = ce[u$2];
							if (l$2) return ie = l$2.nextPos, l$2.result;
							if (e$3 = ie, (t$2 = Se()) !== s$1) {
								for (r$2 = [], n$2 = ie, (o$2 = ge()) !== s$1 && (a$2 = Se()) !== s$1 ? n$2 = o$2 = [o$2, a$2] : (ie = n$2, n$2 = s$1); n$2 !== s$1;) r$2.push(n$2), n$2 = ie, (o$2 = ge()) !== s$1 && (a$2 = Se()) !== s$1 ? n$2 = o$2 = [o$2, a$2] : (ie = n$2, n$2 = s$1);
								r$2 === s$1 ? (ie = e$3, e$3 = s$1) : (i$2 = t$2, e$3 = t$2 = r$2.reduce((function(e$4, t$3) {
									return {
										type: t$3[0],
										left: e$4,
										right: t$3[1]
									};
								}), i$2));
							} else ie = e$3, e$3 = s$1;
							return ce[u$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function Se() {
							var e$3, r$2, n$2, o$2, a$2, i$2, u$2, l$2 = 32 * ie + 8, c$2 = ce[l$2];
							if (c$2) return ie = c$2.nextPos, c$2.result;
							if (e$3 = ie, t$1.charCodeAt(ie) === 33 ? (r$2 = "!", ie++) : (r$2 = s$1, de(v$1)), r$2 === s$1 && (r$2 = null), r$2 !== s$1) {
								if (n$2 = [], (o$2 = _e()) !== s$1) for (; o$2 !== s$1;) n$2.push(o$2), o$2 = _e();
								else n$2 = s$1;
								n$2 === s$1 ? (ie = e$3, e$3 = s$1) : (a$2 = r$2, u$2 = (i$2 = n$2).length === 1 ? i$2[0] : {
									type: "compound",
									selectors: i$2
								}, a$2 && (u$2.subject = !0), e$3 = r$2 = u$2);
							} else ie = e$3, e$3 = s$1;
							return ce[l$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function _e() {
							var e$3, r$2 = 32 * ie + 9, n$2 = ce[r$2];
							return n$2 ? (ie = n$2.nextPos, n$2.result) : ((e$3 = function() {
								var e$4, r$3, n$3 = 32 * ie + 10, o$2 = ce[n$3];
								return o$2 ? (ie = o$2.nextPos, o$2.result) : (t$1.charCodeAt(ie) === 42 ? (r$3 = "*", ie++) : (r$3 = s$1, de(g$1)), r$3 !== s$1 && (r$3 = {
									type: "wildcard",
									value: r$3
								}), e$4 = r$3, ce[n$3] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2 = 32 * ie + 11, a$2 = ce[o$2];
								return a$2 ? (ie = a$2.nextPos, a$2.result) : (e$4 = ie, t$1.charCodeAt(ie) === 35 ? (r$3 = "#", ie++) : (r$3 = s$1, de(A$1)), r$3 === s$1 && (r$3 = null), r$3 !== s$1 && (n$3 = ve()) !== s$1 ? e$4 = r$3 = {
									type: "identifier",
									value: n$3
								} : (ie = e$4, e$4 = s$1), ce[o$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2 = 32 * ie + 12, i$2 = ce[a$2];
								return i$2 ? (ie = i$2.nextPos, i$2.result) : (e$4 = ie, t$1.charCodeAt(ie) === 91 ? (r$3 = "[", ie++) : (r$3 = s$1, de(E)), r$3 !== s$1 && xe() !== s$1 && (n$3 = function() {
									var e$5, r$4, n$4, o$3, a$3 = 32 * ie + 16, i$3 = ce[a$3];
									return i$3 ? (ie = i$3.nextPos, i$3.result) : (e$5 = ie, (r$4 = Ce()) !== s$1 && xe() !== s$1 && (n$4 = function() {
										var e$6, r$5, n$5, o$4 = 32 * ie + 14, a$4 = ce[o$4];
										return a$4 ? (ie = a$4.nextPos, a$4.result) : (e$6 = ie, t$1.charCodeAt(ie) === 33 ? (r$5 = "!", ie++) : (r$5 = s$1, de(v$1)), r$5 === s$1 && (r$5 = null), r$5 === s$1 ? (ie = e$6, e$6 = s$1) : (t$1.charCodeAt(ie) === 61 ? (n$5 = "=", ie++) : (n$5 = s$1, de(C)), n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (r$5 = w(r$5), e$6 = r$5)), ce[o$4] = {
											nextPos: ie,
											result: e$6
										}, e$6);
									}()) !== s$1 && xe() !== s$1 ? ((o$3 = function() {
										var e$6, r$5, n$5, o$4, a$4, i$4 = 32 * ie + 20, u$2 = ce[i$4];
										if (u$2) return ie = u$2.nextPos, u$2.result;
										if (e$6 = ie, t$1.substr(ie, 5) === "type(" ? (r$5 = "type(", ie += 5) : (r$5 = s$1, de(q)), r$5 !== s$1) if (xe() !== s$1) {
											if (n$5 = [], V.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(G)), o$4 !== s$1) for (; o$4 !== s$1;) n$5.push(o$4), V.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(G));
											else n$5 = s$1;
											n$5 !== s$1 && (o$4 = xe()) !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (a$4 = ")", ie++) : (a$4 = s$1, de(z)), a$4 === s$1 ? (ie = e$6, e$6 = s$1) : (r$5 = {
												type: "type",
												value: n$5.join("")
											}, e$6 = r$5)) : (ie = e$6, e$6 = s$1);
										} else ie = e$6, e$6 = s$1;
										else ie = e$6, e$6 = s$1;
										return ce[i$4] = {
											nextPos: ie,
											result: e$6
										}, e$6;
									}()) === s$1 && (o$3 = function() {
										var e$6, r$5, n$5, o$4, a$4, i$4, u$2 = 32 * ie + 22, l$2 = ce[u$2];
										if (l$2) return ie = l$2.nextPos, l$2.result;
										if (e$6 = ie, t$1.charCodeAt(ie) === 47 ? (r$5 = "/", ie++) : (r$5 = s$1, de($)), r$5 !== s$1) {
											if (n$5 = [], J.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(Q)), o$4 !== s$1) for (; o$4 !== s$1;) n$5.push(o$4), J.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(Q));
											else n$5 = s$1;
											n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (t$1.charCodeAt(ie) === 47 ? (o$4 = "/", ie++) : (o$4 = s$1, de($)), o$4 === s$1 ? (ie = e$6, e$6 = s$1) : ((a$4 = function() {
												var e$7, r$6, n$6 = 32 * ie + 21, o$5 = ce[n$6];
												if (o$5) return ie = o$5.nextPos, o$5.result;
												if (e$7 = [], H.test(t$1.charAt(ie)) ? (r$6 = t$1.charAt(ie), ie++) : (r$6 = s$1, de(Y)), r$6 !== s$1) for (; r$6 !== s$1;) e$7.push(r$6), H.test(t$1.charAt(ie)) ? (r$6 = t$1.charAt(ie), ie++) : (r$6 = s$1, de(Y));
												else e$7 = s$1;
												return ce[n$6] = {
													nextPos: ie,
													result: e$7
												}, e$7;
											}()) === s$1 && (a$4 = null), a$4 === s$1 ? (ie = e$6, e$6 = s$1) : (i$4 = a$4, r$5 = {
												type: "regexp",
												value: new RegExp(n$5.join(""), i$4 ? i$4.join("") : "")
											}, e$6 = r$5)));
										} else ie = e$6, e$6 = s$1;
										return ce[u$2] = {
											nextPos: ie,
											result: e$6
										}, e$6;
									}()), o$3 === s$1 ? (ie = e$5, e$5 = s$1) : (r$4 = I(r$4, n$4, o$3), e$5 = r$4)) : (ie = e$5, e$5 = s$1), e$5 === s$1 && (e$5 = ie, (r$4 = Ce()) !== s$1 && xe() !== s$1 && (n$4 = function() {
										var e$6, r$5, n$5, o$4 = 32 * ie + 13, a$4 = ce[o$4];
										return a$4 ? (ie = a$4.nextPos, a$4.result) : (e$6 = ie, S.test(t$1.charAt(ie)) ? (r$5 = t$1.charAt(ie), ie++) : (r$5 = s$1, de(_)), r$5 === s$1 && (r$5 = null), r$5 === s$1 ? (ie = e$6, e$6 = s$1) : (t$1.charCodeAt(ie) === 61 ? (n$5 = "=", ie++) : (n$5 = s$1, de(C)), n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (r$5 = w(r$5), e$6 = r$5)), e$6 === s$1 && (P.test(t$1.charAt(ie)) ? (e$6 = t$1.charAt(ie), ie++) : (e$6 = s$1, de(k))), ce[o$4] = {
											nextPos: ie,
											result: e$6
										}, e$6);
									}()) !== s$1 && xe() !== s$1 ? ((o$3 = function() {
										var e$6, r$5, n$5, o$4, a$4, i$4, u$2 = 32 * ie + 17, l$2 = ce[u$2];
										if (l$2) return ie = l$2.nextPos, l$2.result;
										if (e$6 = ie, t$1.charCodeAt(ie) === 34 ? (r$5 = "\"", ie++) : (r$5 = s$1, de(j)), r$5 !== s$1) {
											for (n$5 = [], T.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(F)), o$4 === s$1 && (o$4 = ie, t$1.charCodeAt(ie) === 92 ? (a$4 = "\\", ie++) : (a$4 = s$1, de(R)), a$4 === s$1 ? (ie = o$4, o$4 = s$1) : (t$1.length > ie ? (i$4 = t$1.charAt(ie), ie++) : (i$4 = s$1, de(O)), i$4 === s$1 ? (ie = o$4, o$4 = s$1) : (a$4 = L(a$4, i$4), o$4 = a$4))); o$4 !== s$1;) n$5.push(o$4), T.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(F)), o$4 === s$1 && (o$4 = ie, t$1.charCodeAt(ie) === 92 ? (a$4 = "\\", ie++) : (a$4 = s$1, de(R)), a$4 === s$1 ? (ie = o$4, o$4 = s$1) : (t$1.length > ie ? (i$4 = t$1.charAt(ie), ie++) : (i$4 = s$1, de(O)), i$4 === s$1 ? (ie = o$4, o$4 = s$1) : (a$4 = L(a$4, i$4), o$4 = a$4)));
											n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (t$1.charCodeAt(ie) === 34 ? (o$4 = "\"", ie++) : (o$4 = s$1, de(j)), o$4 === s$1 ? (ie = e$6, e$6 = s$1) : (r$5 = M(n$5), e$6 = r$5));
										} else ie = e$6, e$6 = s$1;
										if (e$6 === s$1) if (e$6 = ie, t$1.charCodeAt(ie) === 39 ? (r$5 = "'", ie++) : (r$5 = s$1, de(B)), r$5 !== s$1) {
											for (n$5 = [], U.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(K)), o$4 === s$1 && (o$4 = ie, t$1.charCodeAt(ie) === 92 ? (a$4 = "\\", ie++) : (a$4 = s$1, de(R)), a$4 === s$1 ? (ie = o$4, o$4 = s$1) : (t$1.length > ie ? (i$4 = t$1.charAt(ie), ie++) : (i$4 = s$1, de(O)), i$4 === s$1 ? (ie = o$4, o$4 = s$1) : (a$4 = L(a$4, i$4), o$4 = a$4))); o$4 !== s$1;) n$5.push(o$4), U.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(K)), o$4 === s$1 && (o$4 = ie, t$1.charCodeAt(ie) === 92 ? (a$4 = "\\", ie++) : (a$4 = s$1, de(R)), a$4 === s$1 ? (ie = o$4, o$4 = s$1) : (t$1.length > ie ? (i$4 = t$1.charAt(ie), ie++) : (i$4 = s$1, de(O)), i$4 === s$1 ? (ie = o$4, o$4 = s$1) : (a$4 = L(a$4, i$4), o$4 = a$4)));
											n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (t$1.charCodeAt(ie) === 39 ? (o$4 = "'", ie++) : (o$4 = s$1, de(B)), o$4 === s$1 ? (ie = e$6, e$6 = s$1) : (r$5 = M(n$5), e$6 = r$5));
										} else ie = e$6, e$6 = s$1;
										return ce[u$2] = {
											nextPos: ie,
											result: e$6
										}, e$6;
									}()) === s$1 && (o$3 = function() {
										var e$6, r$5, n$5, o$4, a$4, i$4, u$2, l$2 = 32 * ie + 18, c$2 = ce[l$2];
										if (c$2) return ie = c$2.nextPos, c$2.result;
										for (e$6 = ie, r$5 = ie, n$5 = [], N.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(W)); o$4 !== s$1;) n$5.push(o$4), N.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(W));
										if (n$5 === s$1 ? (ie = r$5, r$5 = s$1) : (t$1.charCodeAt(ie) === 46 ? (o$4 = ".", ie++) : (o$4 = s$1, de(D)), o$4 === s$1 ? (ie = r$5, r$5 = s$1) : r$5 = n$5 = [n$5, o$4]), r$5 === s$1 && (r$5 = null), r$5 !== s$1) {
											if (n$5 = [], N.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(W)), o$4 !== s$1) for (; o$4 !== s$1;) n$5.push(o$4), N.test(t$1.charAt(ie)) ? (o$4 = t$1.charAt(ie), ie++) : (o$4 = s$1, de(W));
											else n$5 = s$1;
											n$5 === s$1 ? (ie = e$6, e$6 = s$1) : (i$4 = n$5, u$2 = (a$4 = r$5) ? [].concat.apply([], a$4).join("") : "", r$5 = {
												type: "literal",
												value: parseFloat(u$2 + i$4.join(""))
											}, e$6 = r$5);
										} else ie = e$6, e$6 = s$1;
										return ce[l$2] = {
											nextPos: ie,
											result: e$6
										}, e$6;
									}()) === s$1 && (o$3 = function() {
										var e$6, t$2, r$5 = 32 * ie + 19, n$5 = ce[r$5];
										return n$5 ? (ie = n$5.nextPos, n$5.result) : ((t$2 = ve()) !== s$1 && (t$2 = {
											type: "literal",
											value: t$2
										}), e$6 = t$2, ce[r$5] = {
											nextPos: ie,
											result: e$6
										}, e$6);
									}()), o$3 === s$1 ? (ie = e$5, e$5 = s$1) : (r$4 = I(r$4, n$4, o$3), e$5 = r$4)) : (ie = e$5, e$5 = s$1), e$5 === s$1 && (e$5 = ie, (r$4 = Ce()) !== s$1 && (r$4 = {
										type: "attribute",
										name: r$4
									}), e$5 = r$4)), ce[a$3] = {
										nextPos: ie,
										result: e$5
									}, e$5);
								}()) !== s$1 && xe() !== s$1 ? (t$1.charCodeAt(ie) === 93 ? (o$2 = "]", ie++) : (o$2 = s$1, de(b)), o$2 === s$1 ? (ie = e$4, e$4 = s$1) : e$4 = r$3 = n$3) : (ie = e$4, e$4 = s$1), ce[a$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2, i$2, u$2, l$2, c$2 = 32 * ie + 23, f$2 = ce[c$2];
								if (f$2) return ie = f$2.nextPos, f$2.result;
								if (e$4 = ie, t$1.charCodeAt(ie) === 46 ? (r$3 = ".", ie++) : (r$3 = s$1, de(D)), r$3 !== s$1) if ((n$3 = ve()) !== s$1) {
									for (o$2 = [], a$2 = ie, t$1.charCodeAt(ie) === 46 ? (i$2 = ".", ie++) : (i$2 = s$1, de(D)), i$2 !== s$1 && (u$2 = ve()) !== s$1 ? a$2 = i$2 = [i$2, u$2] : (ie = a$2, a$2 = s$1); a$2 !== s$1;) o$2.push(a$2), a$2 = ie, t$1.charCodeAt(ie) === 46 ? (i$2 = ".", ie++) : (i$2 = s$1, de(D)), i$2 !== s$1 && (u$2 = ve()) !== s$1 ? a$2 = i$2 = [i$2, u$2] : (ie = a$2, a$2 = s$1);
									o$2 === s$1 ? (ie = e$4, e$4 = s$1) : (l$2 = n$3, r$3 = {
										type: "field",
										name: o$2.reduce((function(e$5, t$2) {
											return e$5 + t$2[0] + t$2[1];
										}), l$2)
									}, e$4 = r$3);
								} else ie = e$4, e$4 = s$1;
								else ie = e$4, e$4 = s$1;
								return ce[c$2] = {
									nextPos: ie,
									result: e$4
								}, e$4;
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2 = 32 * ie + 24, i$2 = ce[a$2];
								return i$2 ? (ie = i$2.nextPos, i$2.result) : (e$4 = ie, t$1.substr(ie, 5) === ":not(" ? (r$3 = ":not(", ie += 5) : (r$3 = s$1, de(X)), r$3 !== s$1 && xe() !== s$1 && (n$3 = Ae()) !== s$1 && xe() !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (o$2 = ")", ie++) : (o$2 = s$1, de(z)), o$2 === s$1 ? (ie = e$4, e$4 = s$1) : e$4 = r$3 = {
									type: "not",
									selectors: n$3
								}) : (ie = e$4, e$4 = s$1), ce[a$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2 = 32 * ie + 25, i$2 = ce[a$2];
								return i$2 ? (ie = i$2.nextPos, i$2.result) : (e$4 = ie, t$1.substr(ie, 9) === ":matches(" ? (r$3 = ":matches(", ie += 9) : (r$3 = s$1, de(Z)), r$3 !== s$1 && xe() !== s$1 && (n$3 = Ae()) !== s$1 && xe() !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (o$2 = ")", ie++) : (o$2 = s$1, de(z)), o$2 === s$1 ? (ie = e$4, e$4 = s$1) : e$4 = r$3 = {
									type: "matches",
									selectors: n$3
								}) : (ie = e$4, e$4 = s$1), ce[a$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2 = 32 * ie + 26, i$2 = ce[a$2];
								return i$2 ? (ie = i$2.nextPos, i$2.result) : (e$4 = ie, t$1.substr(ie, 5) === ":has(" ? (r$3 = ":has(", ie += 5) : (r$3 = s$1, de(ee)), r$3 !== s$1 && xe() !== s$1 && (n$3 = function() {
									var e$5, r$4, n$4, o$3, a$3, i$3, u$2, l$2, c$2 = 32 * ie + 4, f$2 = ce[c$2];
									if (f$2) return ie = f$2.nextPos, f$2.result;
									if (e$5 = ie, (r$4 = Ee()) !== s$1) {
										for (n$4 = [], o$3 = ie, (a$3 = xe()) === s$1 ? (ie = o$3, o$3 = s$1) : (t$1.charCodeAt(ie) === 44 ? (i$3 = ",", ie++) : (i$3 = s$1, de(m$1)), i$3 !== s$1 && (u$2 = xe()) !== s$1 && (l$2 = Ee()) !== s$1 ? o$3 = a$3 = [
											a$3,
											i$3,
											u$2,
											l$2
										] : (ie = o$3, o$3 = s$1)); o$3 !== s$1;) n$4.push(o$3), o$3 = ie, (a$3 = xe()) === s$1 ? (ie = o$3, o$3 = s$1) : (t$1.charCodeAt(ie) === 44 ? (i$3 = ",", ie++) : (i$3 = s$1, de(m$1)), i$3 !== s$1 && (u$2 = xe()) !== s$1 && (l$2 = Ee()) !== s$1 ? o$3 = a$3 = [
											a$3,
											i$3,
											u$2,
											l$2
										] : (ie = o$3, o$3 = s$1));
										n$4 === s$1 ? (ie = e$5, e$5 = s$1) : e$5 = r$4 = x$1(r$4, n$4);
									} else ie = e$5, e$5 = s$1;
									return ce[c$2] = {
										nextPos: ie,
										result: e$5
									}, e$5;
								}()) !== s$1 && xe() !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (o$2 = ")", ie++) : (o$2 = s$1, de(z)), o$2 === s$1 ? (ie = e$4, e$4 = s$1) : e$4 = r$3 = {
									type: "has",
									selectors: n$3
								}) : (ie = e$4, e$4 = s$1), ce[a$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3 = 32 * ie + 27, o$2 = ce[n$3];
								return o$2 ? (ie = o$2.nextPos, o$2.result) : (t$1.substr(ie, 12) === ":first-child" ? (r$3 = ":first-child", ie += 12) : (r$3 = s$1, de(te)), r$3 !== s$1 && (r$3 = we(1)), e$4 = r$3, ce[n$3] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3 = 32 * ie + 28, o$2 = ce[n$3];
								return o$2 ? (ie = o$2.nextPos, o$2.result) : (t$1.substr(ie, 11) === ":last-child" ? (r$3 = ":last-child", ie += 11) : (r$3 = s$1, de(re)), r$3 !== s$1 && (r$3 = Pe(1)), e$4 = r$3, ce[n$3] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2, i$2 = 32 * ie + 29, u$2 = ce[i$2];
								if (u$2) return ie = u$2.nextPos, u$2.result;
								if (e$4 = ie, t$1.substr(ie, 11) === ":nth-child(" ? (r$3 = ":nth-child(", ie += 11) : (r$3 = s$1, de(ne)), r$3 !== s$1) if (xe() !== s$1) {
									if (n$3 = [], N.test(t$1.charAt(ie)) ? (o$2 = t$1.charAt(ie), ie++) : (o$2 = s$1, de(W)), o$2 !== s$1) for (; o$2 !== s$1;) n$3.push(o$2), N.test(t$1.charAt(ie)) ? (o$2 = t$1.charAt(ie), ie++) : (o$2 = s$1, de(W));
									else n$3 = s$1;
									n$3 !== s$1 && (o$2 = xe()) !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (a$2 = ")", ie++) : (a$2 = s$1, de(z)), a$2 === s$1 ? (ie = e$4, e$4 = s$1) : (r$3 = we(parseInt(n$3.join(""), 10)), e$4 = r$3)) : (ie = e$4, e$4 = s$1);
								} else ie = e$4, e$4 = s$1;
								else ie = e$4, e$4 = s$1;
								return ce[i$2] = {
									nextPos: ie,
									result: e$4
								}, e$4;
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2, a$2, i$2 = 32 * ie + 30, u$2 = ce[i$2];
								if (u$2) return ie = u$2.nextPos, u$2.result;
								if (e$4 = ie, t$1.substr(ie, 16) === ":nth-last-child(" ? (r$3 = ":nth-last-child(", ie += 16) : (r$3 = s$1, de(oe)), r$3 !== s$1) if (xe() !== s$1) {
									if (n$3 = [], N.test(t$1.charAt(ie)) ? (o$2 = t$1.charAt(ie), ie++) : (o$2 = s$1, de(W)), o$2 !== s$1) for (; o$2 !== s$1;) n$3.push(o$2), N.test(t$1.charAt(ie)) ? (o$2 = t$1.charAt(ie), ie++) : (o$2 = s$1, de(W));
									else n$3 = s$1;
									n$3 !== s$1 && (o$2 = xe()) !== s$1 ? (t$1.charCodeAt(ie) === 41 ? (a$2 = ")", ie++) : (a$2 = s$1, de(z)), a$2 === s$1 ? (ie = e$4, e$4 = s$1) : (r$3 = Pe(parseInt(n$3.join(""), 10)), e$4 = r$3)) : (ie = e$4, e$4 = s$1);
								} else ie = e$4, e$4 = s$1;
								else ie = e$4, e$4 = s$1;
								return ce[i$2] = {
									nextPos: ie,
									result: e$4
								}, e$4;
							}()) === s$1 && (e$3 = function() {
								var e$4, r$3, n$3, o$2 = 32 * ie + 31, a$2 = ce[o$2];
								return a$2 ? (ie = a$2.nextPos, a$2.result) : (e$4 = ie, t$1.charCodeAt(ie) === 58 ? (r$3 = ":", ie++) : (r$3 = s$1, de(ae)), r$3 !== s$1 && (n$3 = ve()) !== s$1 ? e$4 = r$3 = {
									type: "class",
									name: n$3
								} : (ie = e$4, e$4 = s$1), ce[o$2] = {
									nextPos: ie,
									result: e$4
								}, e$4);
							}()), ce[r$2] = {
								nextPos: ie,
								result: e$3
							}, e$3);
						}
						function Ce() {
							var e$3, r$2, n$2, o$2, a$2, i$2, u$2, l$2, c$2 = 32 * ie + 15, f$2 = ce[c$2];
							if (f$2) return ie = f$2.nextPos, f$2.result;
							if (e$3 = ie, (r$2 = ve()) !== s$1) {
								for (n$2 = [], o$2 = ie, t$1.charCodeAt(ie) === 46 ? (a$2 = ".", ie++) : (a$2 = s$1, de(D)), a$2 !== s$1 && (i$2 = ve()) !== s$1 ? o$2 = a$2 = [a$2, i$2] : (ie = o$2, o$2 = s$1); o$2 !== s$1;) n$2.push(o$2), o$2 = ie, t$1.charCodeAt(ie) === 46 ? (a$2 = ".", ie++) : (a$2 = s$1, de(D)), a$2 !== s$1 && (i$2 = ve()) !== s$1 ? o$2 = a$2 = [a$2, i$2] : (ie = o$2, o$2 = s$1);
								n$2 === s$1 ? (ie = e$3, e$3 = s$1) : (u$2 = r$2, l$2 = n$2, e$3 = r$2 = [].concat.apply([u$2], l$2).join(""));
							} else ie = e$3, e$3 = s$1;
							return ce[c$2] = {
								nextPos: ie,
								result: e$3
							}, e$3;
						}
						function we(e$3) {
							return {
								type: "nth-child",
								index: {
									type: "literal",
									value: e$3
								}
							};
						}
						function Pe(e$3) {
							return {
								type: "nth-last-child",
								index: {
									type: "literal",
									value: e$3
								}
							};
						}
						if ((n$1 = l$1()) !== s$1 && ie === t$1.length) return n$1;
						throw n$1 !== s$1 && ie < t$1.length && de({ type: "end" }), o$1 = le, a$1 = ue < t$1.length ? t$1.charAt(ue) : null, i$1 = ue < t$1.length ? ye(ue, ue + 1) : ye(ue, ue), new e$2(e$2.buildMessage(o$1, a$1), o$1, a$1, i$1);
					}
				};
			}();
		}));
		function u(e$1, t$1) {
			for (var r$1 = 0; r$1 < t$1.length; ++r$1) {
				if (e$1 == null) return e$1;
				e$1 = e$1[t$1[r$1]];
			}
			return e$1;
		}
		var l = typeof WeakMap == "function" ? /* @__PURE__ */ new WeakMap() : null;
		function c(e$1) {
			if (e$1 == null) return function() {
				return !0;
			};
			if (l != null) {
				var t$1 = l.get(e$1);
				return t$1 ?? (t$1 = f(e$1), l.set(e$1, t$1)), t$1;
			}
			return f(e$1);
		}
		function f(t$1) {
			switch (t$1.type) {
				case "wildcard": return function() {
					return !0;
				};
				case "identifier":
					var r$1 = t$1.value.toLowerCase();
					return function(e$1, t$2, n$2) {
						return r$1 === e$1[n$2 && n$2.nodeTypeKey || "type"].toLowerCase();
					};
				case "exactNode": return function(e$1, t$2) {
					return t$2.length === 0;
				};
				case "field":
					var n$1 = t$1.name.split(".");
					return function(e$1, t$2) {
						return function e$2(t$3, r$2, n$2, o$2) {
							for (var a$2 = r$2, i$1 = o$2; i$1 < n$2.length; ++i$1) {
								if (a$2 == null) return !1;
								var s$2 = a$2[n$2[i$1]];
								if (Array.isArray(s$2)) {
									for (var u$1 = 0; u$1 < s$2.length; ++u$1) if (e$2(t$3, s$2[u$1], n$2, i$1 + 1)) return !0;
									return !1;
								}
								a$2 = s$2;
							}
							return t$3 === a$2;
						}(e$1, t$2[n$1.length - 1], n$1, 0);
					};
				case "matches":
					var o$1 = t$1.selectors.map(c);
					return function(e$1, t$2, r$2) {
						for (var n$2 = 0; n$2 < o$1.length; ++n$2) if (o$1[n$2](e$1, t$2, r$2)) return !0;
						return !1;
					};
				case "compound":
					var a$1 = t$1.selectors.map(c);
					return function(e$1, t$2, r$2) {
						for (var n$2 = 0; n$2 < a$1.length; ++n$2) if (!a$1[n$2](e$1, t$2, r$2)) return !1;
						return !0;
					};
				case "not":
					var s$1 = t$1.selectors.map(c);
					return function(e$1, t$2, r$2) {
						for (var n$2 = 0; n$2 < s$1.length; ++n$2) if (s$1[n$2](e$1, t$2, r$2)) return !1;
						return !0;
					};
				case "has":
					var l$1 = t$1.selectors.map(c);
					return function(e$1, t$2, r$2) {
						var n$2 = !1, o$2 = [];
						return i.traverse(e$1, {
							enter: function(e$2, t$3) {
								t$3 != null && o$2.unshift(t$3);
								for (var a$2 = 0; a$2 < l$1.length; ++a$2) if (l$1[a$2](e$2, o$2, r$2)) return n$2 = !0, void this.break();
							},
							leave: function() {
								o$2.shift();
							},
							keys: r$2 && r$2.visitorKeys,
							fallback: r$2 && r$2.fallback || "iteration"
						}), n$2;
					};
				case "child":
					var f$1 = c(t$1.left), p$1 = c(t$1.right);
					return function(e$1, t$2, r$2) {
						return !!(t$2.length > 0 && p$1(e$1, t$2, r$2)) && f$1(t$2[0], t$2.slice(1), r$2);
					};
				case "descendant":
					var h$1 = c(t$1.left), x$1 = c(t$1.right);
					return function(e$1, t$2, r$2) {
						if (x$1(e$1, t$2, r$2)) {
							for (var n$2 = 0, o$2 = t$2.length; n$2 < o$2; ++n$2) if (h$1(t$2[n$2], t$2.slice(n$2 + 1), r$2)) return !0;
						}
						return !1;
					};
				case "attribute":
					var v$1 = t$1.name.split(".");
					switch (t$1.operator) {
						case void 0: return function(e$1) {
							return u(e$1, v$1) != null;
						};
						case "=":
							switch (t$1.value.type) {
								case "regexp": return function(e$1) {
									var r$2 = u(e$1, v$1);
									return typeof r$2 == "string" && t$1.value.value.test(r$2);
								};
								case "literal":
									var g$1 = `${t$1.value.value}`;
									return function(e$1) {
										return g$1 === `${u(e$1, v$1)}`;
									};
								case "type": return function(r$2) {
									return t$1.value.value === e(u(r$2, v$1));
								};
							}
							throw Error(`Unknown selector value type: ${t$1.value.type}`);
						case "!=":
							switch (t$1.value.type) {
								case "regexp": return function(e$1) {
									return !t$1.value.value.test(u(e$1, v$1));
								};
								case "literal":
									var A$1 = `${t$1.value.value}`;
									return function(e$1) {
										return A$1 !== `${u(e$1, v$1)}`;
									};
								case "type": return function(r$2) {
									return t$1.value.value !== e(u(r$2, v$1));
								};
							}
							throw Error(`Unknown selector value type: ${t$1.value.type}`);
						case "<=": return function(e$1) {
							return u(e$1, v$1) <= t$1.value.value;
						};
						case "<": return function(e$1) {
							return u(e$1, v$1) < t$1.value.value;
						};
						case ">": return function(e$1) {
							return u(e$1, v$1) > t$1.value.value;
						};
						case ">=": return function(e$1) {
							return u(e$1, v$1) >= t$1.value.value;
						};
					}
					throw Error(`Unknown operator: ${t$1.operator}`);
				case "sibling":
					var E = c(t$1.left), b = c(t$1.right);
					return function(e$1, r$2, n$2) {
						return b(e$1, r$2, n$2) && y(e$1, E, r$2, "LEFT_SIDE", n$2) || t$1.left.subject && E(e$1, r$2, n$2) && y(e$1, b, r$2, "RIGHT_SIDE", n$2);
					};
				case "adjacent":
					var S = c(t$1.left), _ = c(t$1.right);
					return function(e$1, r$2, n$2) {
						return _(e$1, r$2, n$2) && d(e$1, S, r$2, "LEFT_SIDE", n$2) || t$1.right.subject && S(e$1, r$2, n$2) && d(e$1, _, r$2, "RIGHT_SIDE", n$2);
					};
				case "nth-child":
					var C = t$1.index.value, w = c(t$1.right);
					return function(e$1, t$2, r$2) {
						return w(e$1, t$2, r$2) && m(e$1, t$2, C, r$2);
					};
				case "nth-last-child":
					var P = -t$1.index.value, k = c(t$1.right);
					return function(e$1, t$2, r$2) {
						return k(e$1, t$2, r$2) && m(e$1, t$2, P, r$2);
					};
				case "class":
					var D = t$1.name.toLowerCase();
					return function(e$1, r$2, n$2) {
						if (n$2 && n$2.matchClass) return n$2.matchClass(t$1.name, e$1, r$2);
						if (n$2 && n$2.nodeTypeKey) return !1;
						switch (D) {
							case "statement": if (e$1.type.slice(-9) === "Statement") return !0;
							case "declaration": return e$1.type.slice(-11) === "Declaration";
							case "pattern": if (e$1.type.slice(-7) === "Pattern") return !0;
							case "expression": return e$1.type.slice(-10) === "Expression" || e$1.type.slice(-7) === "Literal" || e$1.type === "Identifier" && (r$2.length === 0 || r$2[0].type !== "MetaProperty") || e$1.type === "MetaProperty";
							case "function": return e$1.type === "FunctionDeclaration" || e$1.type === "FunctionExpression" || e$1.type === "ArrowFunctionExpression";
						}
						throw Error(`Unknown class name: ${t$1.name}`);
					};
			}
			throw Error(`Unknown selector type: ${t$1.type}`);
		}
		function p(e$1, t$1) {
			var r$1 = t$1 && t$1.nodeTypeKey || "type", n$1 = e$1[r$1];
			return t$1 && t$1.visitorKeys && t$1.visitorKeys[n$1] ? t$1.visitorKeys[n$1] : i.VisitorKeys[n$1] ? i.VisitorKeys[n$1] : t$1 && typeof t$1.fallback == "function" ? t$1.fallback(e$1) : Object.keys(e$1).filter((function(e$2) {
				return e$2 !== r$1;
			}));
		}
		function h(t$1, r$1) {
			var n$1 = r$1 && r$1.nodeTypeKey || "type";
			return t$1 !== null && e(t$1) === "object" && typeof t$1[n$1] == "string";
		}
		function y(e$1, r$1, n$1, o$1, a$1) {
			var i$1 = t(n$1, 1)[0];
			if (!i$1) return !1;
			for (var s$1 = p(i$1, a$1), u$1 = 0; u$1 < s$1.length; ++u$1) {
				var l$1 = i$1[s$1[u$1]];
				if (Array.isArray(l$1)) {
					var c$1 = l$1.indexOf(e$1);
					if (c$1 < 0) continue;
					var f$1 = void 0, y$1 = void 0;
					o$1 === "LEFT_SIDE" ? (f$1 = 0, y$1 = c$1) : (f$1 = c$1 + 1, y$1 = l$1.length);
					for (var d$1 = f$1; d$1 < y$1; ++d$1) if (h(l$1[d$1], a$1) && r$1(l$1[d$1], n$1, a$1)) return !0;
				}
			}
			return !1;
		}
		function d(e$1, r$1, n$1, o$1, a$1) {
			var i$1 = t(n$1, 1)[0];
			if (!i$1) return !1;
			for (var s$1 = p(i$1, a$1), u$1 = 0; u$1 < s$1.length; ++u$1) {
				var l$1 = i$1[s$1[u$1]];
				if (Array.isArray(l$1)) {
					var c$1 = l$1.indexOf(e$1);
					if (c$1 < 0) continue;
					if (o$1 === "LEFT_SIDE" && c$1 > 0 && h(l$1[c$1 - 1], a$1) && r$1(l$1[c$1 - 1], n$1, a$1) || o$1 === "RIGHT_SIDE" && c$1 < l$1.length - 1 && h(l$1[c$1 + 1], a$1) && r$1(l$1[c$1 + 1], n$1, a$1)) return !0;
				}
			}
			return !1;
		}
		function m(e$1, r$1, n$1, o$1) {
			if (n$1 === 0) return !1;
			var a$1 = t(r$1, 1)[0];
			if (!a$1) return !1;
			for (var i$1 = p(a$1, o$1), s$1 = 0; s$1 < i$1.length; ++s$1) {
				var u$1 = a$1[i$1[s$1]];
				if (Array.isArray(u$1)) {
					var l$1 = n$1 < 0 ? u$1.length + n$1 : n$1 - 1;
					if (l$1 >= 0 && l$1 < u$1.length && u$1[l$1] === e$1) return !0;
				}
			}
			return !1;
		}
		function x(t$1, n$1, o$1, a$1) {
			if (n$1) {
				var s$1 = [], u$1 = c(n$1), l$1 = function t$2(n$2, o$2) {
					if (n$2 == null || e(n$2) != "object") return [];
					o$2 ??= n$2;
					for (var a$2 = n$2.subject ? [o$2] : [], i$1 = Object.keys(n$2), s$2 = 0; s$2 < i$1.length; ++s$2) {
						var u$2 = i$1[s$2], l$2 = n$2[u$2];
						a$2.push.apply(a$2, r(t$2(l$2, u$2 === "left" ? l$2 : o$2)));
					}
					return a$2;
				}(n$1).map(c);
				i.traverse(t$1, {
					enter: function(e$1, t$2) {
						if (t$2 != null && s$1.unshift(t$2), u$1(e$1, s$1, a$1)) if (l$1.length) for (var r$1 = 0, n$2 = l$1.length; r$1 < n$2; ++r$1) {
							l$1[r$1](e$1, s$1, a$1) && o$1(e$1, t$2, s$1);
							for (var i$1 = 0, c$1 = s$1.length; i$1 < c$1; ++i$1) {
								var f$1 = s$1.slice(i$1 + 1);
								l$1[r$1](s$1[i$1], f$1, a$1) && o$1(s$1[i$1], t$2, f$1);
							}
						}
						else o$1(e$1, t$2, s$1);
					},
					leave: function() {
						s$1.shift();
					},
					keys: a$1 && a$1.visitorKeys,
					fallback: a$1 && a$1.fallback || "iteration"
				});
			}
		}
		function v(e$1, t$1, r$1) {
			var n$1 = [];
			return x(e$1, t$1, (function(e$2) {
				n$1.push(e$2);
			}), r$1), n$1;
		}
		function g(e$1) {
			return s.parse(e$1);
		}
		function A(e$1, t$1, r$1) {
			return v(e$1, g(t$1), r$1);
		}
		return A.parse = g, A.match = v, A.traverse = x, A.matches = function(e$1, t$1, r$1, n$1) {
			return !t$1 || !!e$1 && (r$1 ||= [], c(t$1)(e$1, r$1, n$1));
		}, A.query = A, A;
	}));
})))(), 1);
const ancestors = [], { isArray: isArray$1 } = Array;
function walkNode(node, visitors) {
	if (node != null) if (isArray$1(node)) {
		let len = node.length;
		for (let i = 0; i < len; i++) walkNode(node[i], visitors);
	} else switch (node.type) {
		case "DebuggerStatement":
			walkDebuggerStatement(node, visitors);
			break;
		case "EmptyStatement":
			walkEmptyStatement(node, visitors);
			break;
		case "Literal":
			walkLiteral(node, visitors);
			break;
		case "PrivateIdentifier":
			walkPrivateIdentifier(node, visitors);
			break;
		case "Super":
			walkSuper(node, visitors);
			break;
		case "TemplateElement":
			walkTemplateElement(node, visitors);
			break;
		case "ThisExpression":
			walkThisExpression(node, visitors);
			break;
		case "JSXClosingFragment":
			walkJSXClosingFragment(node, visitors);
			break;
		case "JSXEmptyExpression":
			walkJSXEmptyExpression(node, visitors);
			break;
		case "JSXIdentifier":
			walkJSXIdentifier(node, visitors);
			break;
		case "JSXOpeningFragment":
			walkJSXOpeningFragment(node, visitors);
			break;
		case "JSXText":
			walkJSXText(node, visitors);
			break;
		case "TSAnyKeyword":
			walkTSAnyKeyword(node, visitors);
			break;
		case "TSBigIntKeyword":
			walkTSBigIntKeyword(node, visitors);
			break;
		case "TSBooleanKeyword":
			walkTSBooleanKeyword(node, visitors);
			break;
		case "TSIntrinsicKeyword":
			walkTSIntrinsicKeyword(node, visitors);
			break;
		case "TSJSDocUnknownType":
			walkTSJSDocUnknownType(node, visitors);
			break;
		case "TSNeverKeyword":
			walkTSNeverKeyword(node, visitors);
			break;
		case "TSNullKeyword":
			walkTSNullKeyword(node, visitors);
			break;
		case "TSNumberKeyword":
			walkTSNumberKeyword(node, visitors);
			break;
		case "TSObjectKeyword":
			walkTSObjectKeyword(node, visitors);
			break;
		case "TSStringKeyword":
			walkTSStringKeyword(node, visitors);
			break;
		case "TSSymbolKeyword":
			walkTSSymbolKeyword(node, visitors);
			break;
		case "TSThisType":
			walkTSThisType(node, visitors);
			break;
		case "TSUndefinedKeyword":
			walkTSUndefinedKeyword(node, visitors);
			break;
		case "TSUnknownKeyword":
			walkTSUnknownKeyword(node, visitors);
			break;
		case "TSVoidKeyword":
			walkTSVoidKeyword(node, visitors);
			break;
		case "AccessorProperty":
			walkAccessorProperty(node, visitors);
			break;
		case "ArrayExpression":
			walkArrayExpression(node, visitors);
			break;
		case "ArrayPattern":
			walkArrayPattern(node, visitors);
			break;
		case "ArrowFunctionExpression":
			walkArrowFunctionExpression(node, visitors);
			break;
		case "AssignmentExpression":
			walkAssignmentExpression(node, visitors);
			break;
		case "AssignmentPattern":
			walkAssignmentPattern(node, visitors);
			break;
		case "AwaitExpression":
			walkAwaitExpression(node, visitors);
			break;
		case "BinaryExpression":
			walkBinaryExpression(node, visitors);
			break;
		case "BlockStatement":
			walkBlockStatement(node, visitors);
			break;
		case "BreakStatement":
			walkBreakStatement(node, visitors);
			break;
		case "CallExpression":
			walkCallExpression(node, visitors);
			break;
		case "CatchClause":
			walkCatchClause(node, visitors);
			break;
		case "ChainExpression":
			walkChainExpression(node, visitors);
			break;
		case "ClassBody":
			walkClassBody(node, visitors);
			break;
		case "ClassDeclaration":
			walkClassDeclaration(node, visitors);
			break;
		case "ClassExpression":
			walkClassExpression(node, visitors);
			break;
		case "ConditionalExpression":
			walkConditionalExpression(node, visitors);
			break;
		case "ContinueStatement":
			walkContinueStatement(node, visitors);
			break;
		case "Decorator":
			walkDecorator(node, visitors);
			break;
		case "DoWhileStatement":
			walkDoWhileStatement(node, visitors);
			break;
		case "ExportAllDeclaration":
			walkExportAllDeclaration(node, visitors);
			break;
		case "ExportDefaultDeclaration":
			walkExportDefaultDeclaration(node, visitors);
			break;
		case "ExportNamedDeclaration":
			walkExportNamedDeclaration(node, visitors);
			break;
		case "ExportSpecifier":
			walkExportSpecifier(node, visitors);
			break;
		case "ExpressionStatement":
			walkExpressionStatement(node, visitors);
			break;
		case "ForInStatement":
			walkForInStatement(node, visitors);
			break;
		case "ForOfStatement":
			walkForOfStatement(node, visitors);
			break;
		case "ForStatement":
			walkForStatement(node, visitors);
			break;
		case "FunctionDeclaration":
			walkFunctionDeclaration(node, visitors);
			break;
		case "FunctionExpression":
			walkFunctionExpression(node, visitors);
			break;
		case "Identifier":
			walkIdentifier(node, visitors);
			break;
		case "IfStatement":
			walkIfStatement(node, visitors);
			break;
		case "ImportAttribute":
			walkImportAttribute(node, visitors);
			break;
		case "ImportDeclaration":
			walkImportDeclaration(node, visitors);
			break;
		case "ImportDefaultSpecifier":
			walkImportDefaultSpecifier(node, visitors);
			break;
		case "ImportExpression":
			walkImportExpression(node, visitors);
			break;
		case "ImportNamespaceSpecifier":
			walkImportNamespaceSpecifier(node, visitors);
			break;
		case "ImportSpecifier":
			walkImportSpecifier(node, visitors);
			break;
		case "LabeledStatement":
			walkLabeledStatement(node, visitors);
			break;
		case "LogicalExpression":
			walkLogicalExpression(node, visitors);
			break;
		case "MemberExpression":
			walkMemberExpression(node, visitors);
			break;
		case "MetaProperty":
			walkMetaProperty(node, visitors);
			break;
		case "MethodDefinition":
			walkMethodDefinition(node, visitors);
			break;
		case "NewExpression":
			walkNewExpression(node, visitors);
			break;
		case "ObjectExpression":
			walkObjectExpression(node, visitors);
			break;
		case "ObjectPattern":
			walkObjectPattern(node, visitors);
			break;
		case "ParenthesizedExpression":
			walkParenthesizedExpression(node, visitors);
			break;
		case "Program":
			walkProgram(node, visitors);
			break;
		case "Property":
			walkProperty(node, visitors);
			break;
		case "PropertyDefinition":
			walkPropertyDefinition(node, visitors);
			break;
		case "RestElement":
			walkRestElement(node, visitors);
			break;
		case "ReturnStatement":
			walkReturnStatement(node, visitors);
			break;
		case "SequenceExpression":
			walkSequenceExpression(node, visitors);
			break;
		case "SpreadElement":
			walkSpreadElement(node, visitors);
			break;
		case "StaticBlock":
			walkStaticBlock(node, visitors);
			break;
		case "SwitchCase":
			walkSwitchCase(node, visitors);
			break;
		case "SwitchStatement":
			walkSwitchStatement(node, visitors);
			break;
		case "TaggedTemplateExpression":
			walkTaggedTemplateExpression(node, visitors);
			break;
		case "TemplateLiteral":
			walkTemplateLiteral(node, visitors);
			break;
		case "ThrowStatement":
			walkThrowStatement(node, visitors);
			break;
		case "TryStatement":
			walkTryStatement(node, visitors);
			break;
		case "UnaryExpression":
			walkUnaryExpression(node, visitors);
			break;
		case "UpdateExpression":
			walkUpdateExpression(node, visitors);
			break;
		case "V8IntrinsicExpression":
			walkV8IntrinsicExpression(node, visitors);
			break;
		case "VariableDeclaration":
			walkVariableDeclaration(node, visitors);
			break;
		case "VariableDeclarator":
			walkVariableDeclarator(node, visitors);
			break;
		case "WhileStatement":
			walkWhileStatement(node, visitors);
			break;
		case "WithStatement":
			walkWithStatement(node, visitors);
			break;
		case "YieldExpression":
			walkYieldExpression(node, visitors);
			break;
		case "JSXAttribute":
			walkJSXAttribute(node, visitors);
			break;
		case "JSXClosingElement":
			walkJSXClosingElement(node, visitors);
			break;
		case "JSXElement":
			walkJSXElement(node, visitors);
			break;
		case "JSXExpressionContainer":
			walkJSXExpressionContainer(node, visitors);
			break;
		case "JSXFragment":
			walkJSXFragment(node, visitors);
			break;
		case "JSXMemberExpression":
			walkJSXMemberExpression(node, visitors);
			break;
		case "JSXNamespacedName":
			walkJSXNamespacedName(node, visitors);
			break;
		case "JSXOpeningElement":
			walkJSXOpeningElement(node, visitors);
			break;
		case "JSXSpreadAttribute":
			walkJSXSpreadAttribute(node, visitors);
			break;
		case "JSXSpreadChild":
			walkJSXSpreadChild(node, visitors);
			break;
		case "TSAbstractAccessorProperty":
			walkTSAbstractAccessorProperty(node, visitors);
			break;
		case "TSAbstractMethodDefinition":
			walkTSAbstractMethodDefinition(node, visitors);
			break;
		case "TSAbstractPropertyDefinition":
			walkTSAbstractPropertyDefinition(node, visitors);
			break;
		case "TSArrayType":
			walkTSArrayType(node, visitors);
			break;
		case "TSAsExpression":
			walkTSAsExpression(node, visitors);
			break;
		case "TSCallSignatureDeclaration":
			walkTSCallSignatureDeclaration(node, visitors);
			break;
		case "TSClassImplements":
			walkTSClassImplements(node, visitors);
			break;
		case "TSConditionalType":
			walkTSConditionalType(node, visitors);
			break;
		case "TSConstructSignatureDeclaration":
			walkTSConstructSignatureDeclaration(node, visitors);
			break;
		case "TSConstructorType":
			walkTSConstructorType(node, visitors);
			break;
		case "TSDeclareFunction":
			walkTSDeclareFunction(node, visitors);
			break;
		case "TSEmptyBodyFunctionExpression":
			walkTSEmptyBodyFunctionExpression(node, visitors);
			break;
		case "TSEnumBody":
			walkTSEnumBody(node, visitors);
			break;
		case "TSEnumDeclaration":
			walkTSEnumDeclaration(node, visitors);
			break;
		case "TSEnumMember":
			walkTSEnumMember(node, visitors);
			break;
		case "TSExportAssignment":
			walkTSExportAssignment(node, visitors);
			break;
		case "TSExternalModuleReference":
			walkTSExternalModuleReference(node, visitors);
			break;
		case "TSFunctionType":
			walkTSFunctionType(node, visitors);
			break;
		case "TSImportEqualsDeclaration":
			walkTSImportEqualsDeclaration(node, visitors);
			break;
		case "TSImportType":
			walkTSImportType(node, visitors);
			break;
		case "TSIndexSignature":
			walkTSIndexSignature(node, visitors);
			break;
		case "TSIndexedAccessType":
			walkTSIndexedAccessType(node, visitors);
			break;
		case "TSInferType":
			walkTSInferType(node, visitors);
			break;
		case "TSInstantiationExpression":
			walkTSInstantiationExpression(node, visitors);
			break;
		case "TSInterfaceBody":
			walkTSInterfaceBody(node, visitors);
			break;
		case "TSInterfaceDeclaration":
			walkTSInterfaceDeclaration(node, visitors);
			break;
		case "TSInterfaceHeritage":
			walkTSInterfaceHeritage(node, visitors);
			break;
		case "TSIntersectionType":
			walkTSIntersectionType(node, visitors);
			break;
		case "TSJSDocNonNullableType":
			walkTSJSDocNonNullableType(node, visitors);
			break;
		case "TSJSDocNullableType":
			walkTSJSDocNullableType(node, visitors);
			break;
		case "TSLiteralType":
			walkTSLiteralType(node, visitors);
			break;
		case "TSMappedType":
			walkTSMappedType(node, visitors);
			break;
		case "TSMethodSignature":
			walkTSMethodSignature(node, visitors);
			break;
		case "TSModuleBlock":
			walkTSModuleBlock(node, visitors);
			break;
		case "TSModuleDeclaration":
			walkTSModuleDeclaration(node, visitors);
			break;
		case "TSNamedTupleMember":
			walkTSNamedTupleMember(node, visitors);
			break;
		case "TSNamespaceExportDeclaration":
			walkTSNamespaceExportDeclaration(node, visitors);
			break;
		case "TSNonNullExpression":
			walkTSNonNullExpression(node, visitors);
			break;
		case "TSOptionalType":
			walkTSOptionalType(node, visitors);
			break;
		case "TSParameterProperty":
			walkTSParameterProperty(node, visitors);
			break;
		case "TSParenthesizedType":
			walkTSParenthesizedType(node, visitors);
			break;
		case "TSPropertySignature":
			walkTSPropertySignature(node, visitors);
			break;
		case "TSQualifiedName":
			walkTSQualifiedName(node, visitors);
			break;
		case "TSRestType":
			walkTSRestType(node, visitors);
			break;
		case "TSSatisfiesExpression":
			walkTSSatisfiesExpression(node, visitors);
			break;
		case "TSTemplateLiteralType":
			walkTSTemplateLiteralType(node, visitors);
			break;
		case "TSTupleType":
			walkTSTupleType(node, visitors);
			break;
		case "TSTypeAliasDeclaration":
			walkTSTypeAliasDeclaration(node, visitors);
			break;
		case "TSTypeAnnotation":
			walkTSTypeAnnotation(node, visitors);
			break;
		case "TSTypeAssertion":
			walkTSTypeAssertion(node, visitors);
			break;
		case "TSTypeLiteral":
			walkTSTypeLiteral(node, visitors);
			break;
		case "TSTypeOperator":
			walkTSTypeOperator(node, visitors);
			break;
		case "TSTypeParameter":
			walkTSTypeParameter(node, visitors);
			break;
		case "TSTypeParameterDeclaration":
			walkTSTypeParameterDeclaration(node, visitors);
			break;
		case "TSTypeParameterInstantiation":
			walkTSTypeParameterInstantiation(node, visitors);
			break;
		case "TSTypePredicate":
			walkTSTypePredicate(node, visitors);
			break;
		case "TSTypeQuery":
			walkTSTypeQuery(node, visitors);
			break;
		case "TSTypeReference":
			walkTSTypeReference(node, visitors);
			break;
		case "TSUnionType":
			walkTSUnionType(node, visitors);
			break;
	}
}
function walkDebuggerStatement(node, visitors) {
	let visit = visitors[0];
	visit !== null && visit(node);
}
function walkEmptyStatement(node, visitors) {
	let visit = visitors[1];
	visit !== null && visit(node);
}
function walkLiteral(node, visitors) {
	let visit = visitors[2];
	visit !== null && visit(node);
}
function walkPrivateIdentifier(node, visitors) {
	let visit = visitors[3];
	visit !== null && visit(node);
}
function walkSuper(node, visitors) {
	let visit = visitors[4];
	visit !== null && visit(node);
}
function walkTemplateElement(node, visitors) {
	let visit = visitors[5];
	visit !== null && visit(node);
}
function walkThisExpression(node, visitors) {
	let visit = visitors[6];
	visit !== null && visit(node);
}
function walkJSXClosingFragment(node, visitors) {
	let visit = visitors[7];
	visit !== null && visit(node);
}
function walkJSXEmptyExpression(node, visitors) {
	let visit = visitors[8];
	visit !== null && visit(node);
}
function walkJSXIdentifier(node, visitors) {
	let visit = visitors[9];
	visit !== null && visit(node);
}
function walkJSXOpeningFragment(node, visitors) {
	let visit = visitors[10];
	visit !== null && visit(node);
}
function walkJSXText(node, visitors) {
	let visit = visitors[11];
	visit !== null && visit(node);
}
function walkTSAnyKeyword(node, visitors) {
	let visit = visitors[12];
	visit !== null && visit(node);
}
function walkTSBigIntKeyword(node, visitors) {
	let visit = visitors[13];
	visit !== null && visit(node);
}
function walkTSBooleanKeyword(node, visitors) {
	let visit = visitors[14];
	visit !== null && visit(node);
}
function walkTSIntrinsicKeyword(node, visitors) {
	let visit = visitors[15];
	visit !== null && visit(node);
}
function walkTSJSDocUnknownType(node, visitors) {
	let visit = visitors[16];
	visit !== null && visit(node);
}
function walkTSNeverKeyword(node, visitors) {
	let visit = visitors[17];
	visit !== null && visit(node);
}
function walkTSNullKeyword(node, visitors) {
	let visit = visitors[18];
	visit !== null && visit(node);
}
function walkTSNumberKeyword(node, visitors) {
	let visit = visitors[19];
	visit !== null && visit(node);
}
function walkTSObjectKeyword(node, visitors) {
	let visit = visitors[20];
	visit !== null && visit(node);
}
function walkTSStringKeyword(node, visitors) {
	let visit = visitors[21];
	visit !== null && visit(node);
}
function walkTSSymbolKeyword(node, visitors) {
	let visit = visitors[22];
	visit !== null && visit(node);
}
function walkTSThisType(node, visitors) {
	let visit = visitors[23];
	visit !== null && visit(node);
}
function walkTSUndefinedKeyword(node, visitors) {
	let visit = visitors[24];
	visit !== null && visit(node);
}
function walkTSUnknownKeyword(node, visitors) {
	let visit = visitors[25];
	visit !== null && visit(node);
}
function walkTSVoidKeyword(node, visitors) {
	let visit = visitors[26];
	visit !== null && visit(node);
}
function walkAccessorProperty(node, visitors) {
	let enterExit = visitors[27], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrayExpression(node, visitors) {
	let enterExit = visitors[28], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.elements, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrayPattern(node, visitors) {
	let enterExit = visitors[29], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.elements, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrowFunctionExpression(node, visitors) {
	let enterExit = visitors[30], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAssignmentExpression(node, visitors) {
	let enterExit = visitors[31], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAssignmentPattern(node, visitors) {
	let enterExit = visitors[32], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAwaitExpression(node, visitors) {
	let enterExit = visitors[33], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBinaryExpression(node, visitors) {
	let enterExit = visitors[34], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBlockStatement(node, visitors) {
	let enterExit = visitors[35], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBreakStatement(node, visitors) {
	let enterExit = visitors[36], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.label, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkCallExpression(node, visitors) {
	let enterExit = visitors[37], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.callee, visitors), walkNode(node.typeArguments, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkCatchClause(node, visitors) {
	let enterExit = visitors[38], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.param, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkChainExpression(node, visitors) {
	let enterExit = visitors[39], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassBody(node, visitors) {
	let enterExit = visitors[40], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassDeclaration(node, visitors) {
	let enterExit = visitors[41], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.superClass, visitors), walkNode(node.superTypeArguments, visitors), walkNode(node.implements, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassExpression(node, visitors) {
	let enterExit = visitors[42], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.superClass, visitors), walkNode(node.superTypeArguments, visitors), walkNode(node.implements, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkConditionalExpression(node, visitors) {
	let enterExit = visitors[43], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), walkNode(node.alternate, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkContinueStatement(node, visitors) {
	let enterExit = visitors[44], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.label, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkDecorator(node, visitors) {
	let enterExit = visitors[45], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkDoWhileStatement(node, visitors) {
	let enterExit = visitors[46], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), walkNode(node.test, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportAllDeclaration(node, visitors) {
	let enterExit = visitors[47], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.exported, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportDefaultDeclaration(node, visitors) {
	let enterExit = visitors[48], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.declaration, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportNamedDeclaration(node, visitors) {
	let enterExit = visitors[49], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.declaration, visitors), walkNode(node.specifiers, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportSpecifier(node, visitors) {
	let enterExit = visitors[50], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.local, visitors), walkNode(node.exported, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExpressionStatement(node, visitors) {
	let enterExit = visitors[51], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForInStatement(node, visitors) {
	let enterExit = visitors[52], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForOfStatement(node, visitors) {
	let enterExit = visitors[53], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForStatement(node, visitors) {
	let enterExit = visitors[54], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.init, visitors), walkNode(node.test, visitors), walkNode(node.update, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkFunctionDeclaration(node, visitors) {
	let enterExit = visitors[55], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkFunctionExpression(node, visitors) {
	let enterExit = visitors[56], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkIdentifier(node, visitors) {
	let enterExit = visitors[57], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkIfStatement(node, visitors) {
	let enterExit = visitors[58], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), walkNode(node.alternate, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportAttribute(node, visitors) {
	let enterExit = visitors[59], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportDeclaration(node, visitors) {
	let enterExit = visitors[60], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.specifiers, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportDefaultSpecifier(node, visitors) {
	let enterExit = visitors[61], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportExpression(node, visitors) {
	let enterExit = visitors[62], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.source, visitors), walkNode(node.options, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportNamespaceSpecifier(node, visitors) {
	let enterExit = visitors[63], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportSpecifier(node, visitors) {
	let enterExit = visitors[64], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.imported, visitors), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkLabeledStatement(node, visitors) {
	let enterExit = visitors[65], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.label, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkLogicalExpression(node, visitors) {
	let enterExit = visitors[66], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMemberExpression(node, visitors) {
	let enterExit = visitors[67], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMetaProperty(node, visitors) {
	let enterExit = visitors[68], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.meta, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMethodDefinition(node, visitors) {
	let enterExit = visitors[69], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkNewExpression(node, visitors) {
	let enterExit = visitors[70], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.callee, visitors), walkNode(node.typeArguments, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkObjectExpression(node, visitors) {
	let enterExit = visitors[71], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.properties, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkObjectPattern(node, visitors) {
	let enterExit = visitors[72], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.properties, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkParenthesizedExpression(node, visitors) {
	let enterExit = visitors[73], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkProgram(node, visitors) {
	let enterExit = visitors[74], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkProperty(node, visitors) {
	let enterExit = visitors[75], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkPropertyDefinition(node, visitors) {
	let enterExit = visitors[76], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkRestElement(node, visitors) {
	let enterExit = visitors[77], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.argument, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkReturnStatement(node, visitors) {
	let enterExit = visitors[78], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSequenceExpression(node, visitors) {
	let enterExit = visitors[79], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expressions, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSpreadElement(node, visitors) {
	let enterExit = visitors[80], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkStaticBlock(node, visitors) {
	let enterExit = visitors[81], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSwitchCase(node, visitors) {
	let enterExit = visitors[82], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSwitchStatement(node, visitors) {
	let enterExit = visitors[83], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.discriminant, visitors), walkNode(node.cases, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTaggedTemplateExpression(node, visitors) {
	let enterExit = visitors[84], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.tag, visitors), walkNode(node.typeArguments, visitors), walkNode(node.quasi, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTemplateLiteral(node, visitors) {
	let enterExit = visitors[85], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.quasis, visitors), walkNode(node.expressions, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkThrowStatement(node, visitors) {
	let enterExit = visitors[86], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTryStatement(node, visitors) {
	let enterExit = visitors[87], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.block, visitors), walkNode(node.handler, visitors), walkNode(node.finalizer, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkUnaryExpression(node, visitors) {
	let enterExit = visitors[88], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkUpdateExpression(node, visitors) {
	let enterExit = visitors[89], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkV8IntrinsicExpression(node, visitors) {
	let enterExit = visitors[90], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkVariableDeclaration(node, visitors) {
	let enterExit = visitors[91], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.declarations, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkVariableDeclarator(node, visitors) {
	let enterExit = visitors[92], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.init, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkWhileStatement(node, visitors) {
	let enterExit = visitors[93], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkWithStatement(node, visitors) {
	let enterExit = visitors[94], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkYieldExpression(node, visitors) {
	let enterExit = visitors[95], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXAttribute(node, visitors) {
	let enterExit = visitors[96], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXClosingElement(node, visitors) {
	let enterExit = visitors[97], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.name, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXElement(node, visitors) {
	let enterExit = visitors[98], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.openingElement, visitors), walkNode(node.children, visitors), walkNode(node.closingElement, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXExpressionContainer(node, visitors) {
	let enterExit = visitors[99], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXFragment(node, visitors) {
	let enterExit = visitors[100], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.openingFragment, visitors), walkNode(node.children, visitors), walkNode(node.closingFragment, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXMemberExpression(node, visitors) {
	let enterExit = visitors[101], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXNamespacedName(node, visitors) {
	let enterExit = visitors[102], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.namespace, visitors), walkNode(node.name, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXOpeningElement(node, visitors) {
	let enterExit = visitors[103], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.typeArguments, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXSpreadAttribute(node, visitors) {
	let enterExit = visitors[104], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXSpreadChild(node, visitors) {
	let enterExit = visitors[105], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractAccessorProperty(node, visitors) {
	let enterExit = visitors[106], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractMethodDefinition(node, visitors) {
	let enterExit = visitors[107], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractPropertyDefinition(node, visitors) {
	let enterExit = visitors[108], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSArrayType(node, visitors) {
	let enterExit = visitors[109], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.elementType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAsExpression(node, visitors) {
	let enterExit = visitors[110], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSCallSignatureDeclaration(node, visitors) {
	let enterExit = visitors[111], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSClassImplements(node, visitors) {
	let enterExit = visitors[112], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConditionalType(node, visitors) {
	let enterExit = visitors[113], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.checkType, visitors), walkNode(node.extendsType, visitors), walkNode(node.trueType, visitors), walkNode(node.falseType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConstructSignatureDeclaration(node, visitors) {
	let enterExit = visitors[114], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConstructorType(node, visitors) {
	let enterExit = visitors[115], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSDeclareFunction(node, visitors) {
	let enterExit = visitors[116], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEmptyBodyFunctionExpression(node, visitors) {
	let enterExit = visitors[117], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumBody(node, visitors) {
	let enterExit = visitors[118], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.members, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumDeclaration(node, visitors) {
	let enterExit = visitors[119], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumMember(node, visitors) {
	let enterExit = visitors[120], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.initializer, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSExportAssignment(node, visitors) {
	let enterExit = visitors[121], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSExternalModuleReference(node, visitors) {
	let enterExit = visitors[122], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSFunctionType(node, visitors) {
	let enterExit = visitors[123], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSImportEqualsDeclaration(node, visitors) {
	let enterExit = visitors[124], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.moduleReference, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSImportType(node, visitors) {
	let enterExit = visitors[125], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.argument, visitors), walkNode(node.options, visitors), walkNode(node.qualifier, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIndexSignature(node, visitors) {
	let enterExit = visitors[126], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.parameters, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIndexedAccessType(node, visitors) {
	let enterExit = visitors[127], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.objectType, visitors), walkNode(node.indexType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInferType(node, visitors) {
	let enterExit = visitors[128], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeParameter, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInstantiationExpression(node, visitors) {
	let enterExit = visitors[129], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceBody(node, visitors) {
	let enterExit = visitors[130], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceDeclaration(node, visitors) {
	let enterExit = visitors[131], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.extends, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceHeritage(node, visitors) {
	let enterExit = visitors[132], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIntersectionType(node, visitors) {
	let enterExit = visitors[133], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSJSDocNonNullableType(node, visitors) {
	let enterExit = visitors[134], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSJSDocNullableType(node, visitors) {
	let enterExit = visitors[135], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSLiteralType(node, visitors) {
	let enterExit = visitors[136], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.literal, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSMappedType(node, visitors) {
	let enterExit = visitors[137], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.constraint, visitors), walkNode(node.nameType, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSMethodSignature(node, visitors) {
	let enterExit = visitors[138], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSModuleBlock(node, visitors) {
	let enterExit = visitors[139], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSModuleDeclaration(node, visitors) {
	let enterExit = visitors[140], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNamedTupleMember(node, visitors) {
	let enterExit = visitors[141], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.label, visitors), walkNode(node.elementType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNamespaceExportDeclaration(node, visitors) {
	let enterExit = visitors[142], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNonNullExpression(node, visitors) {
	let enterExit = visitors[143], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSOptionalType(node, visitors) {
	let enterExit = visitors[144], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSParameterProperty(node, visitors) {
	let enterExit = visitors[145], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.parameter, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSParenthesizedType(node, visitors) {
	let enterExit = visitors[146], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSPropertySignature(node, visitors) {
	let enterExit = visitors[147], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSQualifiedName(node, visitors) {
	let enterExit = visitors[148], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSRestType(node, visitors) {
	let enterExit = visitors[149], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSSatisfiesExpression(node, visitors) {
	let enterExit = visitors[150], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTemplateLiteralType(node, visitors) {
	let enterExit = visitors[151], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.quasis, visitors), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTupleType(node, visitors) {
	let enterExit = visitors[152], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.elementTypes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAliasDeclaration(node, visitors) {
	let enterExit = visitors[153], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAnnotation(node, visitors) {
	let enterExit = visitors[154], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAssertion(node, visitors) {
	let enterExit = visitors[155], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeLiteral(node, visitors) {
	let enterExit = visitors[156], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.members, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeOperator(node, visitors) {
	let enterExit = visitors[157], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameter(node, visitors) {
	let enterExit = visitors[158], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.constraint, visitors), walkNode(node.default, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameterDeclaration(node, visitors) {
	let enterExit = visitors[159], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.params, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameterInstantiation(node, visitors) {
	let enterExit = visitors[160], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.params, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypePredicate(node, visitors) {
	let enterExit = visitors[161], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.parameterName, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeQuery(node, visitors) {
	let enterExit = visitors[162], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.exprName, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeReference(node, visitors) {
	let enterExit = visitors[163], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.typeName, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSUnionType(node, visitors) {
	let enterExit = visitors[164], exit = null;
	if (enterExit !== null) {
		let enter;
		({enter, exit} = enterExit), enter !== null && enter(node);
	}
	ancestors.unshift(node), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
const ObjectKeys$1 = Object.keys, { matches: esqueryMatches, parse: esqueryParse } = import_esquery_min.default, ESQUERY_OPTIONS = {
	nodeTypeKey: "type",
	visitorKeys: keys_default,
	fallback: (node) => ObjectKeys$1(node).filter(filterKey),
	matchClass: (_className, _node, _ancestors) => !1
}, filterKey = (key) => key !== "parent" && key !== "range" && key !== "loc", cache = /* @__PURE__ */ new Map([]), EMPTY_TYPE_IDS_ARRAY = [];
function parseSelector(key) {
	let selector = cache.get(key);
	if (selector !== void 0) return selector;
	let esquerySelector = esqueryParse(key);
	return selector = {
		typeIds: null,
		esquerySelector,
		isComplex: !1,
		attributeCount: 0,
		identifierCount: 0
	}, selector.typeIds = analyzeSelector(esquerySelector, selector), cache.set(key, selector), selector;
}
function analyzeSelector(esquerySelector, selector) {
	switch (esquerySelector.type) {
		case "identifier": {
			selector.identifierCount++;
			let typeId = NODE_TYPE_IDS_MAP.get(esquerySelector.value);
			return typeId === void 0 ? EMPTY_TYPE_IDS_ARRAY : [typeId];
		}
		case "not":
			for (let i = 0, childSelectors = esquerySelector.selectors, len = childSelectors.length; i < len; i++) analyzeSelector(childSelectors[i], selector);
			return selector.isComplex = !0, null;
		case "matches": {
			let nodeTypes = [];
			for (let i = 0, childSelectors = esquerySelector.selectors, len = childSelectors.length; i < len; i++) {
				let childNodeTypes = analyzeSelector(childSelectors[i], selector);
				childNodeTypes === null ? nodeTypes = null : nodeTypes !== null && nodeTypes.push(...childNodeTypes);
			}
			return nodeTypes === null ? null : [...new Set(nodeTypes)];
		}
		case "compound": {
			let childSelectors = esquerySelector.selectors, len = childSelectors.length;
			if (len === 0) return [];
			let nodeTypes = null;
			for (let i = 0; i < len; i++) {
				let childNodeTypes = analyzeSelector(childSelectors[i], selector);
				childNodeTypes !== null && (nodeTypes = nodeTypes === null ? childNodeTypes : childNodeTypes.filter((nodeType) => nodeTypes.includes(nodeType)));
			}
			return nodeTypes;
		}
		case "attribute":
		case "field":
		case "nth-child":
		case "nth-last-child": return selector.isComplex = !0, selector.attributeCount++, null;
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent": return selector.isComplex = !0, analyzeSelector(esquerySelector.left, selector), analyzeSelector(esquerySelector.right, selector);
		case "class": return esquerySelector.name === "function" ? FUNCTION_NODE_TYPE_IDS : (selector.isComplex = !0, null);
		case "wildcard": return null;
		default: return selector.isComplex = !0, null;
	}
}
function wrapVisitFnWithSelectorMatch(visitFn, esquerySelector) {
	return (node) => {
		esqueryMatches(node, esquerySelector, ancestors, ESQUERY_OPTIONS) && visitFn(node);
	};
}
const ObjectKeys = Object.keys, { isArray } = Array, compiledVisitor = [];
for (let i = 165; i !== 0; i--) compiledVisitor.push(null);
const mergedLeafVisitorTypeIds = [], mergedEnterVisitorTypeIds = [], mergedExitVisitorTypeIds = [];
for (let i = 27; i !== 0; i--) mergedLeafVisitorTypeIds.push(0);
for (let i = 138; i !== 0; i--) mergedEnterVisitorTypeIds.push(0), mergedExitVisitorTypeIds.push(0);
mergedLeafVisitorTypeIds.length = 0, mergedEnterVisitorTypeIds.length = 0, mergedExitVisitorTypeIds.length = 0;
let hasActiveVisitors = !1;
const enterExitObjectCache = [];
let enterExitObjectCacheNextIndex = 0;
function getEnterExitObject() {
	if (enterExitObjectCacheNextIndex < enterExitObjectCache.length) return enterExitObjectCache[enterExitObjectCacheNextIndex++];
	let enterExit = {
		enter: null,
		exit: null
	};
	return enterExitObjectCache.push(enterExit), enterExitObjectCacheNextIndex++, enterExit;
}
const visitFnArrayCache = [];
let visitFnArrayCacheNextIndex = 0;
function createVisitFnArray(visit1, visit2) {
	if (visitFnArrayCacheNextIndex < visitFnArrayCache.length) {
		let arr$1 = visitFnArrayCache[visitFnArrayCacheNextIndex++];
		return arr$1.push(visit1, visit2), arr$1;
	}
	let arr = [visit1, visit2];
	return visitFnArrayCache.push(arr), visitFnArrayCacheNextIndex++, arr;
}
function initCompiledVisitor() {
	for (let i = 0; i < 165; i++) compiledVisitor[i] = null;
	for (let i = 0; i < enterExitObjectCacheNextIndex; i++) {
		let enterExit = enterExitObjectCache[i];
		enterExit.enter = null, enterExit.exit = null;
	}
	enterExitObjectCacheNextIndex = 0;
}
function addVisitorToCompiled(visitor) {
	if (typeof visitor != "object" || !visitor) throw TypeError("Visitor returned from `create` method must be an object");
	let keys = ObjectKeys(visitor), keysLen = keys.length;
	if (keysLen !== 0) {
		hasActiveVisitors = !0;
		for (let i = 0; i < keysLen; i++) {
			let name = keys[i], visitFn = visitor[name];
			if (typeof visitFn != "function") throw TypeError(`'${name}' property of visitor object is not a function`);
			let isExit = name.endsWith(":exit");
			isExit && (name = name.slice(0, -5));
			let typeId = NODE_TYPE_IDS_MAP.get(name);
			if (typeId !== void 0) {
				addVisitFn(typeId, isExit, visitFn);
				continue;
			}
			if (name !== "*") {
				let selector = parseSelector(name);
				selector.isComplex && (visitFn = wrapVisitFnWithSelectorMatch(visitFn, selector.esquerySelector));
				let { typeIds } = selector;
				if (typeIds !== null) {
					for (let i$1 = 0, len = typeIds.length; i$1 < len; i$1++) addVisitFn(typeIds[i$1], isExit, visitFn);
					continue;
				}
			}
			for (typeId = 0; typeId < 27; typeId++) addLeafVisitFn(typeId, isExit, visitFn);
			for (; typeId < 165; typeId++) addNonLeafVisitFn(typeId, isExit, visitFn);
		}
	}
}
function addVisitFn(typeId, isExit, visitFn) {
	typeId < 27 ? addLeafVisitFn(typeId, isExit, visitFn) : addNonLeafVisitFn(typeId, isExit, visitFn);
}
function addLeafVisitFn(typeId, isExit, visitFn) {
	let existing = compiledVisitor[typeId];
	existing === null ? compiledVisitor[typeId] = visitFn : isArray(existing) ? isExit ? existing.push(visitFn) : existing.splice(existing.length - 1, 0, visitFn) : (compiledVisitor[typeId] = isExit ? createVisitFnArray(existing, visitFn) : createVisitFnArray(visitFn, existing), mergedLeafVisitorTypeIds.push(typeId));
}
function addNonLeafVisitFn(typeId, isExit, visitFn) {
	let existing = compiledVisitor[typeId];
	if (existing === null) {
		let enterExit = compiledVisitor[typeId] = getEnterExitObject();
		isExit ? enterExit.exit = visitFn : enterExit.enter = visitFn;
	} else if (isExit) {
		let { exit } = existing;
		exit === null ? existing.exit = visitFn : isArray(exit) ? exit.push(visitFn) : (existing.exit = createVisitFnArray(exit, visitFn), mergedExitVisitorTypeIds.push(typeId));
	} else {
		let { enter } = existing;
		enter === null ? existing.enter = visitFn : isArray(enter) ? enter.push(visitFn) : (existing.enter = createVisitFnArray(enter, visitFn), mergedEnterVisitorTypeIds.push(typeId));
	}
}
function finalizeCompiledVisitor() {
	if (hasActiveVisitors === !1) return !1;
	for (let i = mergedLeafVisitorTypeIds.length - 1; i >= 0; i--) {
		let typeId = mergedLeafVisitorTypeIds[i];
		compiledVisitor[typeId] = mergeVisitFns(compiledVisitor[typeId]);
	}
	for (let i = mergedEnterVisitorTypeIds.length - 1; i >= 0; i--) {
		let enterExit = compiledVisitor[mergedEnterVisitorTypeIds[i]];
		enterExit.enter = mergeVisitFns(enterExit.enter);
	}
	for (let i = mergedExitVisitorTypeIds.length - 1; i >= 0; i--) {
		let enterExit = compiledVisitor[mergedExitVisitorTypeIds[i]];
		enterExit.exit = mergeVisitFns(enterExit.exit);
	}
	return mergedLeafVisitorTypeIds.length = 0, mergedEnterVisitorTypeIds.length = 0, mergedExitVisitorTypeIds.length = 0, visitFnArrayCacheNextIndex = 0, hasActiveVisitors = !1, !0;
}
function mergeVisitFns(visitFns) {
	let numVisitFns = visitFns.length, merger;
	if (mergers.length <= numVisitFns) {
		for (; mergers.length < numVisitFns;) mergers.push(null);
		merger = createMerger(numVisitFns), mergers.push(merger);
	} else merger = mergers[numVisitFns], merger === null && (merger = mergers[numVisitFns] = createMerger(numVisitFns));
	let mergedFn = merger(...visitFns);
	return visitFns.length = 0, mergedFn;
}
function createMerger(fnCount) {
	let args = [], body = "return node=>{";
	for (let i = 1; i <= fnCount; i++) args.push(`visit${i}`), body += `visit${i}(node);`;
	return body += "}", args.push(body), Function(...args);
}
const mergers = [
	null,
	null,
	(visit1, visit2) => (node) => {
		visit1(node), visit2(node);
	},
	(visit1, visit2, visit3) => (node) => {
		visit1(node), visit2(node), visit3(node);
	},
	(visit1, visit2, visit3, visit4) => (node) => {
		visit1(node), visit2(node), visit3(node), visit4(node);
	},
	(visit1, visit2, visit3, visit4, visit5) => (node) => {
		visit1(node), visit2(node), visit3(node), visit4(node), visit5(node);
	}
], buffers = [], afterHooks = [];
function lintFile(filePath, bufferId, buffer$1, ruleIds) {
	try {
		return lintFileImpl(filePath, bufferId, buffer$1, ruleIds), JSON.stringify({ Success: diagnostics });
	} catch (err) {
		return JSON.stringify({ Failure: getErrorMessage(err) });
	} finally {
		diagnostics.length = 0;
	}
}
function lintFileImpl(filePath, bufferId, buffer$1, ruleIds) {
	if (buffer$1 === null) buffer$1 = buffers[bufferId];
	else {
		let { buffer: arrayBuffer, byteOffset } = buffer$1;
		buffer$1.uint32 = new Uint32Array(arrayBuffer, byteOffset), buffer$1.float64 = new Float64Array(arrayBuffer, byteOffset);
		for (let i = bufferId - buffers.length; i >= 0; i--) buffers.push(null);
		buffers[bufferId] = buffer$1;
	}
	if (typeof filePath != "string" || filePath.length === 0) throw Error("expected filePath to be a non-zero length string");
	if (!Array.isArray(ruleIds) || ruleIds.length === 0) throw Error("Expected `ruleIds` to be a non-zero len array");
	setupSourceForFile(buffer$1, !1), initCompiledVisitor();
	for (let i = 0; i < ruleIds.length; i++) {
		let ruleAndContext = registeredRules[ruleIds[i]], { rule, context } = ruleAndContext;
		setupContextForFile(context, i, filePath);
		let { visitor } = ruleAndContext;
		if (visitor === null) visitor = rule.create(context);
		else {
			let { beforeHook, afterHook } = ruleAndContext;
			if (beforeHook !== null && beforeHook() === !1) continue;
			afterHook !== null && afterHooks.push(afterHook);
		}
		addVisitorToCompiled(visitor);
	}
	if (finalizeCompiledVisitor() && (ast === null && initAst(), walkProgram(ast, compiledVisitor)), afterHooks.length !== 0) {
		for (let afterHook of afterHooks) afterHook();
		afterHooks.length = 0;
	}
	resetSource();
}
export { lintFile, loadPlugin };
