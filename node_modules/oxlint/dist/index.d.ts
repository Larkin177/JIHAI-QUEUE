declare namespace types_d_exports {
  export { AccessorProperty, AccessorPropertyType, Argument, ArrayAssignmentTarget, ArrayExpression, ArrayExpressionElement, ArrayPattern, ArrowFunctionExpression, AssignmentExpression, AssignmentOperator, AssignmentPattern, AssignmentTarget, AssignmentTargetMaybeDefault, AssignmentTargetPattern, AssignmentTargetProperty, AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty, AssignmentTargetRest, AssignmentTargetWithDefault, AwaitExpression, BigIntLiteral, BinaryExpression, BinaryOperator, BindingIdentifier, BindingPattern, BindingPatternKind, BindingProperty, BindingRestElement, BlockStatement, BooleanLiteral, BreakStatement, CallExpression, CatchClause, ChainElement, ChainExpression, Class, ClassBody, ClassElement, ClassType, ComputedMemberExpression, ConditionalExpression, ContinueStatement, DebuggerStatement, Declaration, Decorator, Directive, DoWhileStatement, EmptyStatement, ExportAllDeclaration, ExportDefaultDeclaration, ExportDefaultDeclarationKind, ExportNamedDeclaration, ExportSpecifier, Expression, ExpressionStatement, ForInStatement, ForOfStatement, ForStatement, ForStatementInit, ForStatementLeft, FormalParameter, FormalParameterRest, Function, FunctionBody, FunctionType, Hashbang, IdentifierName, IdentifierReference, IfStatement, ImportAttribute, ImportAttributeKey, ImportDeclaration, ImportDeclarationSpecifier, ImportDefaultSpecifier, ImportExpression, ImportNamespaceSpecifier, ImportOrExportKind, ImportPhase, ImportSpecifier, JSDocNonNullableType, JSDocNullableType, JSDocUnknownType, JSXAttribute, JSXAttributeItem, JSXAttributeName, JSXAttributeValue, JSXChild, JSXClosingElement, JSXClosingFragment, JSXElement, JSXElementName, JSXEmptyExpression, JSXExpression, JSXExpressionContainer, JSXFragment, JSXIdentifier, JSXMemberExpression, JSXMemberExpressionObject, JSXNamespacedName, JSXOpeningElement, JSXOpeningFragment, JSXSpreadAttribute, JSXSpreadChild, JSXText, LabelIdentifier, LabeledStatement, LogicalExpression, LogicalOperator, MemberExpression, MetaProperty, MethodDefinition, MethodDefinitionKind, MethodDefinitionType, ModuleDeclaration, ModuleExportName, ModuleKind, NewExpression, Node$1 as Node, NullLiteral, NumericLiteral, ObjectAssignmentTarget, ObjectExpression, ObjectPattern, ObjectProperty, ObjectPropertyKind, ParamPattern, ParenthesizedExpression, PrivateFieldExpression, PrivateIdentifier, PrivateInExpression, Program, PropertyDefinition, PropertyDefinitionType, PropertyKey, PropertyKind, RegExpLiteral, ReturnStatement, SequenceExpression, SimpleAssignmentTarget, Span, SpreadElement, Statement, StaticBlock, StaticMemberExpression, StringLiteral, Super, SwitchCase, SwitchStatement, TSAccessibility, TSAnyKeyword, TSArrayType, TSAsExpression, TSBigIntKeyword, TSBooleanKeyword, TSCallSignatureDeclaration, TSClassImplements, TSConditionalType, TSConstructSignatureDeclaration, TSConstructorType, TSEnumBody, TSEnumDeclaration, TSEnumMember, TSEnumMemberName, TSExportAssignment, TSExternalModuleReference, TSFunctionType, TSImportEqualsDeclaration, TSImportType, TSImportTypeQualifiedName, TSImportTypeQualifier, TSIndexSignature, TSIndexSignatureName, TSIndexedAccessType, TSInferType, TSInstantiationExpression, TSInterfaceBody, TSInterfaceDeclaration, TSInterfaceHeritage, TSIntersectionType, TSIntrinsicKeyword, TSLiteral, TSLiteralType, TSMappedType, TSMappedTypeModifierOperator, TSMethodSignature, TSMethodSignatureKind, TSModuleBlock, TSModuleDeclaration, TSModuleDeclarationKind, TSModuleReference, TSNamedTupleMember, TSNamespaceExportDeclaration, TSNeverKeyword, TSNonNullExpression, TSNullKeyword, TSNumberKeyword, TSObjectKeyword, TSOptionalType, TSParameterProperty, TSParenthesizedType, TSPropertySignature, TSQualifiedName, TSRestType, TSSatisfiesExpression, TSSignature, TSStringKeyword, TSSymbolKeyword, TSTemplateLiteralType, TSThisParameter, TSThisType, TSTupleElement, TSTupleType, TSType, TSTypeAliasDeclaration, TSTypeAnnotation, TSTypeAssertion, TSTypeLiteral, TSTypeName, TSTypeOperator, TSTypeOperatorOperator, TSTypeParameter, TSTypeParameterDeclaration, TSTypeParameterInstantiation, TSTypePredicate, TSTypePredicateName, TSTypeQuery, TSTypeQueryExprName, TSTypeReference, TSUndefinedKeyword, TSUnionType, TSUnknownKeyword, TSVoidKeyword, TaggedTemplateExpression, TemplateElement, TemplateElementValue, TemplateLiteral, ThisExpression, ThrowStatement, TryStatement, UnaryExpression, UnaryOperator, UpdateExpression, UpdateOperator, V8IntrinsicExpression, VariableDeclaration, VariableDeclarationKind, VariableDeclarator, WhileStatement, WithStatement, YieldExpression };
}
interface Program extends Span {
  type: 'Program';
  body: Array<Directive | Statement>;
  sourceType: ModuleKind;
  hashbang: Hashbang | null;
  parent?: null;
}
type Expression = BooleanLiteral | NullLiteral | NumericLiteral | BigIntLiteral | RegExpLiteral | StringLiteral | TemplateLiteral | IdentifierReference | MetaProperty | Super | ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | Class | ConditionalExpression | Function | ImportExpression | LogicalExpression | NewExpression | ObjectExpression | ParenthesizedExpression | SequenceExpression | TaggedTemplateExpression | ThisExpression | UnaryExpression | UpdateExpression | YieldExpression | PrivateInExpression | JSXElement | JSXFragment | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression | TSInstantiationExpression | V8IntrinsicExpression | MemberExpression;
interface IdentifierName extends Span {
  type: 'Identifier';
  decorators?: [];
  name: string;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface IdentifierReference extends Span {
  type: 'Identifier';
  decorators?: [];
  name: string;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface BindingIdentifier extends Span {
  type: 'Identifier';
  decorators?: [];
  name: string;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface LabelIdentifier extends Span {
  type: 'Identifier';
  decorators?: [];
  name: string;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface ThisExpression extends Span {
  type: 'ThisExpression';
  parent?: Node$1;
}
interface ArrayExpression extends Span {
  type: 'ArrayExpression';
  elements: Array<ArrayExpressionElement>;
  parent?: Node$1;
}
type ArrayExpressionElement = SpreadElement | null | Expression;
interface ObjectExpression extends Span {
  type: 'ObjectExpression';
  properties: Array<ObjectPropertyKind>;
  parent?: Node$1;
}
type ObjectPropertyKind = ObjectProperty | SpreadElement;
interface ObjectProperty extends Span {
  type: 'Property';
  kind: PropertyKind;
  key: PropertyKey;
  value: Expression;
  method: boolean;
  shorthand: boolean;
  computed: boolean;
  optional?: false;
  parent?: Node$1;
}
type PropertyKey = IdentifierName | PrivateIdentifier | Expression;
type PropertyKind = 'init' | 'get' | 'set';
interface TemplateLiteral extends Span {
  type: 'TemplateLiteral';
  quasis: Array<TemplateElement>;
  expressions: Array<Expression>;
  parent?: Node$1;
}
interface TaggedTemplateExpression extends Span {
  type: 'TaggedTemplateExpression';
  tag: Expression;
  typeArguments?: TSTypeParameterInstantiation | null;
  quasi: TemplateLiteral;
  parent?: Node$1;
}
interface TemplateElement extends Span {
  type: 'TemplateElement';
  value: TemplateElementValue;
  tail: boolean;
  parent?: Node$1;
}
interface TemplateElementValue {
  raw: string;
  cooked: string | null;
}
type MemberExpression = ComputedMemberExpression | StaticMemberExpression | PrivateFieldExpression;
interface ComputedMemberExpression extends Span {
  type: 'MemberExpression';
  object: Expression;
  property: Expression;
  optional: boolean;
  computed: true;
  parent?: Node$1;
}
interface StaticMemberExpression extends Span {
  type: 'MemberExpression';
  object: Expression;
  property: IdentifierName;
  optional: boolean;
  computed: false;
  parent?: Node$1;
}
interface PrivateFieldExpression extends Span {
  type: 'MemberExpression';
  object: Expression;
  property: PrivateIdentifier;
  optional: boolean;
  computed: false;
  parent?: Node$1;
}
interface CallExpression extends Span {
  type: 'CallExpression';
  callee: Expression;
  typeArguments?: TSTypeParameterInstantiation | null;
  arguments: Array<Argument>;
  optional: boolean;
  parent?: Node$1;
}
interface NewExpression extends Span {
  type: 'NewExpression';
  callee: Expression;
  typeArguments?: TSTypeParameterInstantiation | null;
  arguments: Array<Argument>;
  parent?: Node$1;
}
interface MetaProperty extends Span {
  type: 'MetaProperty';
  meta: IdentifierName;
  property: IdentifierName;
  parent?: Node$1;
}
interface SpreadElement extends Span {
  type: 'SpreadElement';
  argument: Expression;
  parent?: Node$1;
}
type Argument = SpreadElement | Expression;
interface UpdateExpression extends Span {
  type: 'UpdateExpression';
  operator: UpdateOperator;
  prefix: boolean;
  argument: SimpleAssignmentTarget;
  parent?: Node$1;
}
interface UnaryExpression extends Span {
  type: 'UnaryExpression';
  operator: UnaryOperator;
  argument: Expression;
  prefix: true;
  parent?: Node$1;
}
interface BinaryExpression extends Span {
  type: 'BinaryExpression';
  left: Expression;
  operator: BinaryOperator;
  right: Expression;
  parent?: Node$1;
}
interface PrivateInExpression extends Span {
  type: 'BinaryExpression';
  left: PrivateIdentifier;
  operator: 'in';
  right: Expression;
  parent?: Node$1;
}
interface LogicalExpression extends Span {
  type: 'LogicalExpression';
  left: Expression;
  operator: LogicalOperator;
  right: Expression;
  parent?: Node$1;
}
interface ConditionalExpression extends Span {
  type: 'ConditionalExpression';
  test: Expression;
  consequent: Expression;
  alternate: Expression;
  parent?: Node$1;
}
interface AssignmentExpression extends Span {
  type: 'AssignmentExpression';
  operator: AssignmentOperator;
  left: AssignmentTarget;
  right: Expression;
  parent?: Node$1;
}
type AssignmentTarget = SimpleAssignmentTarget | AssignmentTargetPattern;
type SimpleAssignmentTarget = IdentifierReference | TSAsExpression | TSSatisfiesExpression | TSNonNullExpression | TSTypeAssertion | MemberExpression;
type AssignmentTargetPattern = ArrayAssignmentTarget | ObjectAssignmentTarget;
interface ArrayAssignmentTarget extends Span {
  type: 'ArrayPattern';
  decorators?: [];
  elements: Array<AssignmentTargetMaybeDefault | AssignmentTargetRest | null>;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface ObjectAssignmentTarget extends Span {
  type: 'ObjectPattern';
  decorators?: [];
  properties: Array<AssignmentTargetProperty | AssignmentTargetRest>;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface AssignmentTargetRest extends Span {
  type: 'RestElement';
  decorators?: [];
  argument: AssignmentTarget;
  optional?: false;
  typeAnnotation?: null;
  value?: null;
  parent?: Node$1;
}
type AssignmentTargetMaybeDefault = AssignmentTargetWithDefault | AssignmentTarget;
interface AssignmentTargetWithDefault extends Span {
  type: 'AssignmentPattern';
  decorators?: [];
  left: AssignmentTarget;
  right: Expression;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
type AssignmentTargetProperty = AssignmentTargetPropertyIdentifier | AssignmentTargetPropertyProperty;
interface AssignmentTargetPropertyIdentifier extends Span {
  type: 'Property';
  kind: 'init';
  key: IdentifierReference;
  value: IdentifierReference | AssignmentTargetWithDefault;
  method: false;
  shorthand: true;
  computed: false;
  optional?: false;
  parent?: Node$1;
}
interface AssignmentTargetPropertyProperty extends Span {
  type: 'Property';
  kind: 'init';
  key: PropertyKey;
  value: AssignmentTargetMaybeDefault;
  method: false;
  shorthand: false;
  computed: boolean;
  optional?: false;
  parent?: Node$1;
}
interface SequenceExpression extends Span {
  type: 'SequenceExpression';
  expressions: Array<Expression>;
  parent?: Node$1;
}
interface Super extends Span {
  type: 'Super';
  parent?: Node$1;
}
interface AwaitExpression extends Span {
  type: 'AwaitExpression';
  argument: Expression;
  parent?: Node$1;
}
interface ChainExpression extends Span {
  type: 'ChainExpression';
  expression: ChainElement;
  parent?: Node$1;
}
type ChainElement = CallExpression | TSNonNullExpression | MemberExpression;
interface ParenthesizedExpression extends Span {
  type: 'ParenthesizedExpression';
  expression: Expression;
  parent?: Node$1;
}
type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | WhileStatement | WithStatement | Declaration | ModuleDeclaration;
interface Directive extends Span {
  type: 'ExpressionStatement';
  expression: StringLiteral;
  directive: string;
  parent?: Node$1;
}
interface Hashbang extends Span {
  type: 'Hashbang';
  value: string;
  parent?: Node$1;
}
interface BlockStatement extends Span {
  type: 'BlockStatement';
  body: Array<Statement>;
  parent?: Node$1;
}
type Declaration = VariableDeclaration | Function | Class | TSTypeAliasDeclaration | TSInterfaceDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration;
interface VariableDeclaration extends Span {
  type: 'VariableDeclaration';
  kind: VariableDeclarationKind;
  declarations: Array<VariableDeclarator>;
  declare?: boolean;
  parent?: Node$1;
}
type VariableDeclarationKind = 'var' | 'let' | 'const' | 'using' | 'await using';
interface VariableDeclarator extends Span {
  type: 'VariableDeclarator';
  id: BindingPattern;
  init: Expression | null;
  definite?: boolean;
  parent?: Node$1;
}
interface EmptyStatement extends Span {
  type: 'EmptyStatement';
  parent?: Node$1;
}
interface ExpressionStatement extends Span {
  type: 'ExpressionStatement';
  expression: Expression;
  directive?: string | null;
  parent?: Node$1;
}
interface IfStatement extends Span {
  type: 'IfStatement';
  test: Expression;
  consequent: Statement;
  alternate: Statement | null;
  parent?: Node$1;
}
interface DoWhileStatement extends Span {
  type: 'DoWhileStatement';
  body: Statement;
  test: Expression;
  parent?: Node$1;
}
interface WhileStatement extends Span {
  type: 'WhileStatement';
  test: Expression;
  body: Statement;
  parent?: Node$1;
}
interface ForStatement extends Span {
  type: 'ForStatement';
  init: ForStatementInit | null;
  test: Expression | null;
  update: Expression | null;
  body: Statement;
  parent?: Node$1;
}
type ForStatementInit = VariableDeclaration | Expression;
interface ForInStatement extends Span {
  type: 'ForInStatement';
  left: ForStatementLeft;
  right: Expression;
  body: Statement;
  parent?: Node$1;
}
type ForStatementLeft = VariableDeclaration | AssignmentTarget;
interface ForOfStatement extends Span {
  type: 'ForOfStatement';
  await: boolean;
  left: ForStatementLeft;
  right: Expression;
  body: Statement;
  parent?: Node$1;
}
interface ContinueStatement extends Span {
  type: 'ContinueStatement';
  label: LabelIdentifier | null;
  parent?: Node$1;
}
interface BreakStatement extends Span {
  type: 'BreakStatement';
  label: LabelIdentifier | null;
  parent?: Node$1;
}
interface ReturnStatement extends Span {
  type: 'ReturnStatement';
  argument: Expression | null;
  parent?: Node$1;
}
interface WithStatement extends Span {
  type: 'WithStatement';
  object: Expression;
  body: Statement;
  parent?: Node$1;
}
interface SwitchStatement extends Span {
  type: 'SwitchStatement';
  discriminant: Expression;
  cases: Array<SwitchCase>;
  parent?: Node$1;
}
interface SwitchCase extends Span {
  type: 'SwitchCase';
  test: Expression | null;
  consequent: Array<Statement>;
  parent?: Node$1;
}
interface LabeledStatement extends Span {
  type: 'LabeledStatement';
  label: LabelIdentifier;
  body: Statement;
  parent?: Node$1;
}
interface ThrowStatement extends Span {
  type: 'ThrowStatement';
  argument: Expression;
  parent?: Node$1;
}
interface TryStatement extends Span {
  type: 'TryStatement';
  block: BlockStatement;
  handler: CatchClause | null;
  finalizer: BlockStatement | null;
  parent?: Node$1;
}
interface CatchClause extends Span {
  type: 'CatchClause';
  param: BindingPattern | null;
  body: BlockStatement;
  parent?: Node$1;
}
interface DebuggerStatement extends Span {
  type: 'DebuggerStatement';
  parent?: Node$1;
}
type BindingPattern = ({
  optional?: boolean;
  typeAnnotation?: TSTypeAnnotation | null;
}) & (BindingIdentifier | ObjectPattern | ArrayPattern | AssignmentPattern);
type BindingPatternKind = BindingIdentifier | ObjectPattern | ArrayPattern | AssignmentPattern;
interface AssignmentPattern extends Span {
  type: 'AssignmentPattern';
  decorators?: [];
  left: BindingPattern;
  right: Expression;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface ObjectPattern extends Span {
  type: 'ObjectPattern';
  decorators?: [];
  properties: Array<BindingProperty | BindingRestElement>;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface BindingProperty extends Span {
  type: 'Property';
  kind: 'init';
  key: PropertyKey;
  value: BindingPattern;
  method: false;
  shorthand: boolean;
  computed: boolean;
  optional?: false;
  parent?: Node$1;
}
interface ArrayPattern extends Span {
  type: 'ArrayPattern';
  decorators?: [];
  elements: Array<BindingPattern | BindingRestElement | null>;
  optional?: false;
  typeAnnotation?: null;
  parent?: Node$1;
}
interface BindingRestElement extends Span {
  type: 'RestElement';
  decorators?: [];
  argument: BindingPattern;
  optional?: false;
  typeAnnotation?: null;
  value?: null;
  parent?: Node$1;
}
interface Function extends Span {
  type: FunctionType;
  id: BindingIdentifier | null;
  generator: boolean;
  async: boolean;
  declare?: boolean;
  typeParameters?: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType?: TSTypeAnnotation | null;
  body: FunctionBody | null;
  expression: false;
  parent?: Node$1;
}
type ParamPattern = FormalParameter | TSParameterProperty | FormalParameterRest;
type FunctionType = 'FunctionDeclaration' | 'FunctionExpression' | 'TSDeclareFunction' | 'TSEmptyBodyFunctionExpression';
interface FormalParameterRest extends Span {
  type: 'RestElement';
  argument: BindingPatternKind;
  decorators?: [];
  optional?: boolean;
  typeAnnotation?: TSTypeAnnotation | null;
  value?: null;
}
type FormalParameter = ({
  decorators?: Array<Decorator>;
}) & BindingPattern;
interface TSParameterProperty extends Span {
  type: 'TSParameterProperty';
  accessibility: TSAccessibility | null;
  decorators: Array<Decorator>;
  override: boolean;
  parameter: FormalParameter;
  readonly: boolean;
  static: boolean;
}
interface FunctionBody extends Span {
  type: 'BlockStatement';
  body: Array<Directive | Statement>;
  parent?: Node$1;
}
interface ArrowFunctionExpression extends Span {
  type: 'ArrowFunctionExpression';
  expression: boolean;
  async: boolean;
  typeParameters?: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType?: TSTypeAnnotation | null;
  body: FunctionBody | Expression;
  id: null;
  generator: false;
  parent?: Node$1;
}
interface YieldExpression extends Span {
  type: 'YieldExpression';
  delegate: boolean;
  argument: Expression | null;
  parent?: Node$1;
}
interface Class extends Span {
  type: ClassType;
  decorators: Array<Decorator>;
  id: BindingIdentifier | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  superClass: Expression | null;
  superTypeArguments?: TSTypeParameterInstantiation | null;
  implements?: Array<TSClassImplements>;
  body: ClassBody;
  abstract?: boolean;
  declare?: boolean;
  parent?: Node$1;
}
type ClassType = 'ClassDeclaration' | 'ClassExpression';
interface ClassBody extends Span {
  type: 'ClassBody';
  body: Array<ClassElement>;
  parent?: Node$1;
}
type ClassElement = StaticBlock | MethodDefinition | PropertyDefinition | AccessorProperty | TSIndexSignature;
interface MethodDefinition extends Span {
  type: MethodDefinitionType;
  decorators: Array<Decorator>;
  key: PropertyKey;
  value: Function;
  kind: MethodDefinitionKind;
  computed: boolean;
  static: boolean;
  override?: boolean;
  optional?: boolean;
  accessibility?: TSAccessibility | null;
  parent?: Node$1;
}
type MethodDefinitionType = 'MethodDefinition' | 'TSAbstractMethodDefinition';
interface PropertyDefinition extends Span {
  type: PropertyDefinitionType;
  decorators: Array<Decorator>;
  key: PropertyKey;
  typeAnnotation?: TSTypeAnnotation | null;
  value: Expression | null;
  computed: boolean;
  static: boolean;
  declare?: boolean;
  override?: boolean;
  optional?: boolean;
  definite?: boolean;
  readonly?: boolean;
  accessibility?: TSAccessibility | null;
  parent?: Node$1;
}
type PropertyDefinitionType = 'PropertyDefinition' | 'TSAbstractPropertyDefinition';
type MethodDefinitionKind = 'constructor' | 'method' | 'get' | 'set';
interface PrivateIdentifier extends Span {
  type: 'PrivateIdentifier';
  name: string;
  parent?: Node$1;
}
interface StaticBlock extends Span {
  type: 'StaticBlock';
  body: Array<Statement>;
  parent?: Node$1;
}
type ModuleDeclaration = ImportDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
type AccessorPropertyType = 'AccessorProperty' | 'TSAbstractAccessorProperty';
interface AccessorProperty extends Span {
  type: AccessorPropertyType;
  decorators: Array<Decorator>;
  key: PropertyKey;
  typeAnnotation?: TSTypeAnnotation | null;
  value: Expression | null;
  computed: boolean;
  static: boolean;
  override?: boolean;
  definite?: boolean;
  accessibility?: TSAccessibility | null;
  declare?: false;
  optional?: false;
  readonly?: false;
  parent?: Node$1;
}
interface ImportExpression extends Span {
  type: 'ImportExpression';
  source: Expression;
  options: Expression | null;
  phase: ImportPhase | null;
  parent?: Node$1;
}
interface ImportDeclaration extends Span {
  type: 'ImportDeclaration';
  specifiers: Array<ImportDeclarationSpecifier>;
  source: StringLiteral;
  phase: ImportPhase | null;
  attributes: Array<ImportAttribute>;
  importKind?: ImportOrExportKind;
  parent?: Node$1;
}
type ImportPhase = 'source' | 'defer';
type ImportDeclarationSpecifier = ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier;
interface ImportSpecifier extends Span {
  type: 'ImportSpecifier';
  imported: ModuleExportName;
  local: BindingIdentifier;
  importKind?: ImportOrExportKind;
  parent?: Node$1;
}
interface ImportDefaultSpecifier extends Span {
  type: 'ImportDefaultSpecifier';
  local: BindingIdentifier;
  parent?: Node$1;
}
interface ImportNamespaceSpecifier extends Span {
  type: 'ImportNamespaceSpecifier';
  local: BindingIdentifier;
  parent?: Node$1;
}
interface ImportAttribute extends Span {
  type: 'ImportAttribute';
  key: ImportAttributeKey;
  value: StringLiteral;
  parent?: Node$1;
}
type ImportAttributeKey = IdentifierName | StringLiteral;
interface ExportNamedDeclaration extends Span {
  type: 'ExportNamedDeclaration';
  declaration: Declaration | null;
  specifiers: Array<ExportSpecifier>;
  source: StringLiteral | null;
  exportKind?: ImportOrExportKind;
  attributes: Array<ImportAttribute>;
  parent?: Node$1;
}
interface ExportDefaultDeclaration extends Span {
  type: 'ExportDefaultDeclaration';
  declaration: ExportDefaultDeclarationKind;
  exportKind?: 'value';
  parent?: Node$1;
}
interface ExportAllDeclaration extends Span {
  type: 'ExportAllDeclaration';
  exported: ModuleExportName | null;
  source: StringLiteral;
  attributes: Array<ImportAttribute>;
  exportKind?: ImportOrExportKind;
  parent?: Node$1;
}
interface ExportSpecifier extends Span {
  type: 'ExportSpecifier';
  local: ModuleExportName;
  exported: ModuleExportName;
  exportKind?: ImportOrExportKind;
  parent?: Node$1;
}
type ExportDefaultDeclarationKind = Function | Class | TSInterfaceDeclaration | Expression;
type ModuleExportName = IdentifierName | IdentifierReference | StringLiteral;
interface V8IntrinsicExpression extends Span {
  type: 'V8IntrinsicExpression';
  name: IdentifierName;
  arguments: Array<Argument>;
  parent?: Node$1;
}
interface BooleanLiteral extends Span {
  type: 'Literal';
  value: boolean;
  raw: string | null;
  parent?: Node$1;
}
interface NullLiteral extends Span {
  type: 'Literal';
  value: null;
  raw: 'null' | null;
  parent?: Node$1;
}
interface NumericLiteral extends Span {
  type: 'Literal';
  value: number;
  raw: string | null;
  parent?: Node$1;
}
interface StringLiteral extends Span {
  type: 'Literal';
  value: string;
  raw: string | null;
  parent?: Node$1;
}
interface BigIntLiteral extends Span {
  type: 'Literal';
  value: bigint;
  raw: string | null;
  bigint: string;
  parent?: Node$1;
}
interface RegExpLiteral extends Span {
  type: 'Literal';
  value: RegExp | null;
  raw: string | null;
  regex: {
    pattern: string;
    flags: string;
  };
  parent?: Node$1;
}
interface JSXElement extends Span {
  type: 'JSXElement';
  openingElement: JSXOpeningElement;
  children: Array<JSXChild>;
  closingElement: JSXClosingElement | null;
  parent?: Node$1;
}
interface JSXOpeningElement extends Span {
  type: 'JSXOpeningElement';
  name: JSXElementName;
  typeArguments?: TSTypeParameterInstantiation | null;
  attributes: Array<JSXAttributeItem>;
  selfClosing: boolean;
  parent?: Node$1;
}
interface JSXClosingElement extends Span {
  type: 'JSXClosingElement';
  name: JSXElementName;
  parent?: Node$1;
}
interface JSXFragment extends Span {
  type: 'JSXFragment';
  openingFragment: JSXOpeningFragment;
  children: Array<JSXChild>;
  closingFragment: JSXClosingFragment;
  parent?: Node$1;
}
interface JSXOpeningFragment extends Span {
  type: 'JSXOpeningFragment';
  attributes?: [];
  selfClosing?: false;
  parent?: Node$1;
}
interface JSXClosingFragment extends Span {
  type: 'JSXClosingFragment';
  parent?: Node$1;
}
type JSXElementName = JSXIdentifier | JSXNamespacedName | JSXMemberExpression;
interface JSXNamespacedName extends Span {
  type: 'JSXNamespacedName';
  namespace: JSXIdentifier;
  name: JSXIdentifier;
  parent?: Node$1;
}
interface JSXMemberExpression extends Span {
  type: 'JSXMemberExpression';
  object: JSXMemberExpressionObject;
  property: JSXIdentifier;
  parent?: Node$1;
}
type JSXMemberExpressionObject = JSXIdentifier | JSXMemberExpression;
interface JSXExpressionContainer extends Span {
  type: 'JSXExpressionContainer';
  expression: JSXExpression;
  parent?: Node$1;
}
type JSXExpression = JSXEmptyExpression | Expression;
interface JSXEmptyExpression extends Span {
  type: 'JSXEmptyExpression';
  parent?: Node$1;
}
type JSXAttributeItem = JSXAttribute | JSXSpreadAttribute;
interface JSXAttribute extends Span {
  type: 'JSXAttribute';
  name: JSXAttributeName;
  value: JSXAttributeValue | null;
  parent?: Node$1;
}
interface JSXSpreadAttribute extends Span {
  type: 'JSXSpreadAttribute';
  argument: Expression;
  parent?: Node$1;
}
type JSXAttributeName = JSXIdentifier | JSXNamespacedName;
type JSXAttributeValue = StringLiteral | JSXExpressionContainer | JSXElement | JSXFragment;
interface JSXIdentifier extends Span {
  type: 'JSXIdentifier';
  name: string;
  parent?: Node$1;
}
type JSXChild = JSXText | JSXElement | JSXFragment | JSXExpressionContainer | JSXSpreadChild;
interface JSXSpreadChild extends Span {
  type: 'JSXSpreadChild';
  expression: Expression;
  parent?: Node$1;
}
interface JSXText extends Span {
  type: 'JSXText';
  value: string;
  raw: string | null;
  parent?: Node$1;
}
interface TSThisParameter extends Span {
  type: 'Identifier';
  decorators: [];
  name: 'this';
  optional: false;
  typeAnnotation: TSTypeAnnotation | null;
  parent?: Node$1;
}
interface TSEnumDeclaration extends Span {
  type: 'TSEnumDeclaration';
  id: BindingIdentifier;
  body: TSEnumBody;
  const: boolean;
  declare: boolean;
  parent?: Node$1;
}
interface TSEnumBody extends Span {
  type: 'TSEnumBody';
  members: Array<TSEnumMember>;
  parent?: Node$1;
}
interface TSEnumMember extends Span {
  type: 'TSEnumMember';
  id: TSEnumMemberName;
  initializer: Expression | null;
  computed: boolean;
  parent?: Node$1;
}
type TSEnumMemberName = IdentifierName | StringLiteral | TemplateLiteral;
interface TSTypeAnnotation extends Span {
  type: 'TSTypeAnnotation';
  typeAnnotation: TSType;
  parent?: Node$1;
}
interface TSLiteralType extends Span {
  type: 'TSLiteralType';
  literal: TSLiteral;
  parent?: Node$1;
}
type TSLiteral = BooleanLiteral | NumericLiteral | BigIntLiteral | StringLiteral | TemplateLiteral | UnaryExpression;
type TSType = TSAnyKeyword | TSBigIntKeyword | TSBooleanKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSArrayType | TSConditionalType | TSConstructorType | TSFunctionType | TSImportType | TSIndexedAccessType | TSInferType | TSIntersectionType | TSLiteralType | TSMappedType | TSNamedTupleMember | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUnionType | TSParenthesizedType | JSDocNullableType | JSDocNonNullableType | JSDocUnknownType;
interface TSConditionalType extends Span {
  type: 'TSConditionalType';
  checkType: TSType;
  extendsType: TSType;
  trueType: TSType;
  falseType: TSType;
  parent?: Node$1;
}
interface TSUnionType extends Span {
  type: 'TSUnionType';
  types: Array<TSType>;
  parent?: Node$1;
}
interface TSIntersectionType extends Span {
  type: 'TSIntersectionType';
  types: Array<TSType>;
  parent?: Node$1;
}
interface TSParenthesizedType extends Span {
  type: 'TSParenthesizedType';
  typeAnnotation: TSType;
  parent?: Node$1;
}
interface TSTypeOperator extends Span {
  type: 'TSTypeOperator';
  operator: TSTypeOperatorOperator;
  typeAnnotation: TSType;
  parent?: Node$1;
}
type TSTypeOperatorOperator = 'keyof' | 'unique' | 'readonly';
interface TSArrayType extends Span {
  type: 'TSArrayType';
  elementType: TSType;
  parent?: Node$1;
}
interface TSIndexedAccessType extends Span {
  type: 'TSIndexedAccessType';
  objectType: TSType;
  indexType: TSType;
  parent?: Node$1;
}
interface TSTupleType extends Span {
  type: 'TSTupleType';
  elementTypes: Array<TSTupleElement>;
  parent?: Node$1;
}
interface TSNamedTupleMember extends Span {
  type: 'TSNamedTupleMember';
  label: IdentifierName;
  elementType: TSTupleElement;
  optional: boolean;
  parent?: Node$1;
}
interface TSOptionalType extends Span {
  type: 'TSOptionalType';
  typeAnnotation: TSType;
  parent?: Node$1;
}
interface TSRestType extends Span {
  type: 'TSRestType';
  typeAnnotation: TSType;
  parent?: Node$1;
}
type TSTupleElement = TSOptionalType | TSRestType | TSType;
interface TSAnyKeyword extends Span {
  type: 'TSAnyKeyword';
  parent?: Node$1;
}
interface TSStringKeyword extends Span {
  type: 'TSStringKeyword';
  parent?: Node$1;
}
interface TSBooleanKeyword extends Span {
  type: 'TSBooleanKeyword';
  parent?: Node$1;
}
interface TSNumberKeyword extends Span {
  type: 'TSNumberKeyword';
  parent?: Node$1;
}
interface TSNeverKeyword extends Span {
  type: 'TSNeverKeyword';
  parent?: Node$1;
}
interface TSIntrinsicKeyword extends Span {
  type: 'TSIntrinsicKeyword';
  parent?: Node$1;
}
interface TSUnknownKeyword extends Span {
  type: 'TSUnknownKeyword';
  parent?: Node$1;
}
interface TSNullKeyword extends Span {
  type: 'TSNullKeyword';
  parent?: Node$1;
}
interface TSUndefinedKeyword extends Span {
  type: 'TSUndefinedKeyword';
  parent?: Node$1;
}
interface TSVoidKeyword extends Span {
  type: 'TSVoidKeyword';
  parent?: Node$1;
}
interface TSSymbolKeyword extends Span {
  type: 'TSSymbolKeyword';
  parent?: Node$1;
}
interface TSThisType extends Span {
  type: 'TSThisType';
  parent?: Node$1;
}
interface TSObjectKeyword extends Span {
  type: 'TSObjectKeyword';
  parent?: Node$1;
}
interface TSBigIntKeyword extends Span {
  type: 'TSBigIntKeyword';
  parent?: Node$1;
}
interface TSTypeReference extends Span {
  type: 'TSTypeReference';
  typeName: TSTypeName;
  typeArguments: TSTypeParameterInstantiation | null;
  parent?: Node$1;
}
type TSTypeName = IdentifierReference | TSQualifiedName | ThisExpression;
interface TSQualifiedName extends Span {
  type: 'TSQualifiedName';
  left: TSTypeName;
  right: IdentifierName;
  parent?: Node$1;
}
interface TSTypeParameterInstantiation extends Span {
  type: 'TSTypeParameterInstantiation';
  params: Array<TSType>;
  parent?: Node$1;
}
interface TSTypeParameter extends Span {
  type: 'TSTypeParameter';
  name: BindingIdentifier;
  constraint: TSType | null;
  default: TSType | null;
  in: boolean;
  out: boolean;
  const: boolean;
  parent?: Node$1;
}
interface TSTypeParameterDeclaration extends Span {
  type: 'TSTypeParameterDeclaration';
  params: Array<TSTypeParameter>;
  parent?: Node$1;
}
interface TSTypeAliasDeclaration extends Span {
  type: 'TSTypeAliasDeclaration';
  id: BindingIdentifier;
  typeParameters: TSTypeParameterDeclaration | null;
  typeAnnotation: TSType;
  declare: boolean;
  parent?: Node$1;
}
type TSAccessibility = 'private' | 'protected' | 'public';
interface TSClassImplements extends Span {
  type: 'TSClassImplements';
  expression: IdentifierReference | ThisExpression | MemberExpression;
  typeArguments: TSTypeParameterInstantiation | null;
  parent?: Node$1;
}
interface TSInterfaceDeclaration extends Span {
  type: 'TSInterfaceDeclaration';
  id: BindingIdentifier;
  typeParameters: TSTypeParameterDeclaration | null;
  extends: Array<TSInterfaceHeritage>;
  body: TSInterfaceBody;
  declare: boolean;
  parent?: Node$1;
}
interface TSInterfaceBody extends Span {
  type: 'TSInterfaceBody';
  body: Array<TSSignature>;
  parent?: Node$1;
}
interface TSPropertySignature extends Span {
  type: 'TSPropertySignature';
  computed: boolean;
  optional: boolean;
  readonly: boolean;
  key: PropertyKey;
  typeAnnotation: TSTypeAnnotation | null;
  accessibility: null;
  static: false;
  parent?: Node$1;
}
type TSSignature = TSIndexSignature | TSPropertySignature | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSMethodSignature;
interface TSIndexSignature extends Span {
  type: 'TSIndexSignature';
  parameters: Array<TSIndexSignatureName>;
  typeAnnotation: TSTypeAnnotation;
  readonly: boolean;
  static: boolean;
  accessibility: null;
  parent?: Node$1;
}
interface TSCallSignatureDeclaration extends Span {
  type: 'TSCallSignatureDeclaration';
  typeParameters: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType: TSTypeAnnotation | null;
  parent?: Node$1;
}
type TSMethodSignatureKind = 'method' | 'get' | 'set';
interface TSMethodSignature extends Span {
  type: 'TSMethodSignature';
  key: PropertyKey;
  computed: boolean;
  optional: boolean;
  kind: TSMethodSignatureKind;
  typeParameters: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType: TSTypeAnnotation | null;
  accessibility: null;
  readonly: false;
  static: false;
  parent?: Node$1;
}
interface TSConstructSignatureDeclaration extends Span {
  type: 'TSConstructSignatureDeclaration';
  typeParameters: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType: TSTypeAnnotation | null;
  parent?: Node$1;
}
interface TSIndexSignatureName extends Span {
  type: 'Identifier';
  decorators: [];
  name: string;
  optional: false;
  typeAnnotation: TSTypeAnnotation;
  parent?: Node$1;
}
interface TSInterfaceHeritage extends Span {
  type: 'TSInterfaceHeritage';
  expression: Expression;
  typeArguments: TSTypeParameterInstantiation | null;
  parent?: Node$1;
}
interface TSTypePredicate extends Span {
  type: 'TSTypePredicate';
  parameterName: TSTypePredicateName;
  asserts: boolean;
  typeAnnotation: TSTypeAnnotation | null;
  parent?: Node$1;
}
type TSTypePredicateName = IdentifierName | TSThisType;
interface TSModuleDeclaration extends Span {
  type: 'TSModuleDeclaration';
  id: BindingIdentifier | StringLiteral | TSQualifiedName;
  body: TSModuleBlock | null;
  kind: TSModuleDeclarationKind;
  declare: boolean;
  global: boolean;
  parent?: Node$1;
}
type TSModuleDeclarationKind = 'global' | 'module' | 'namespace';
interface TSModuleBlock extends Span {
  type: 'TSModuleBlock';
  body: Array<Directive | Statement>;
  parent?: Node$1;
}
interface TSTypeLiteral extends Span {
  type: 'TSTypeLiteral';
  members: Array<TSSignature>;
  parent?: Node$1;
}
interface TSInferType extends Span {
  type: 'TSInferType';
  typeParameter: TSTypeParameter;
  parent?: Node$1;
}
interface TSTypeQuery extends Span {
  type: 'TSTypeQuery';
  exprName: TSTypeQueryExprName;
  typeArguments: TSTypeParameterInstantiation | null;
  parent?: Node$1;
}
type TSTypeQueryExprName = TSImportType | TSTypeName;
interface TSImportType extends Span {
  type: 'TSImportType';
  argument: TSType;
  options: ObjectExpression | null;
  qualifier: TSImportTypeQualifier | null;
  typeArguments: TSTypeParameterInstantiation | null;
  parent?: Node$1;
}
type TSImportTypeQualifier = IdentifierName | TSImportTypeQualifiedName;
interface TSImportTypeQualifiedName extends Span {
  type: 'TSQualifiedName';
  left: TSImportTypeQualifier;
  right: IdentifierName;
  parent?: Node$1;
}
interface TSFunctionType extends Span {
  type: 'TSFunctionType';
  typeParameters: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType: TSTypeAnnotation;
  parent?: Node$1;
}
interface TSConstructorType extends Span {
  type: 'TSConstructorType';
  abstract: boolean;
  typeParameters: TSTypeParameterDeclaration | null;
  params: ParamPattern[];
  returnType: TSTypeAnnotation;
  parent?: Node$1;
}
interface TSMappedType extends Span {
  type: 'TSMappedType';
  key: TSTypeParameter['name'];
  constraint: TSTypeParameter['constraint'];
  nameType: TSType | null;
  typeAnnotation: TSType | null;
  optional: TSMappedTypeModifierOperator | false;
  readonly: TSMappedTypeModifierOperator | null;
  parent?: Node$1;
}
type TSMappedTypeModifierOperator = true | '+' | '-';
interface TSTemplateLiteralType extends Span {
  type: 'TSTemplateLiteralType';
  quasis: Array<TemplateElement>;
  types: Array<TSType>;
  parent?: Node$1;
}
interface TSAsExpression extends Span {
  type: 'TSAsExpression';
  expression: Expression;
  typeAnnotation: TSType;
  parent?: Node$1;
}
interface TSSatisfiesExpression extends Span {
  type: 'TSSatisfiesExpression';
  expression: Expression;
  typeAnnotation: TSType;
  parent?: Node$1;
}
interface TSTypeAssertion extends Span {
  type: 'TSTypeAssertion';
  typeAnnotation: TSType;
  expression: Expression;
  parent?: Node$1;
}
interface TSImportEqualsDeclaration extends Span {
  type: 'TSImportEqualsDeclaration';
  id: BindingIdentifier;
  moduleReference: TSModuleReference;
  importKind: ImportOrExportKind;
  parent?: Node$1;
}
type TSModuleReference = TSExternalModuleReference | TSTypeName;
interface TSExternalModuleReference extends Span {
  type: 'TSExternalModuleReference';
  expression: StringLiteral;
  parent?: Node$1;
}
interface TSNonNullExpression extends Span {
  type: 'TSNonNullExpression';
  expression: Expression;
  parent?: Node$1;
}
interface Decorator extends Span {
  type: 'Decorator';
  expression: Expression;
  parent?: Node$1;
}
interface TSExportAssignment extends Span {
  type: 'TSExportAssignment';
  expression: Expression;
  parent?: Node$1;
}
interface TSNamespaceExportDeclaration extends Span {
  type: 'TSNamespaceExportDeclaration';
  id: IdentifierName;
  parent?: Node$1;
}
interface TSInstantiationExpression extends Span {
  type: 'TSInstantiationExpression';
  expression: Expression;
  typeArguments: TSTypeParameterInstantiation;
  parent?: Node$1;
}
type ImportOrExportKind = 'value' | 'type';
interface JSDocNullableType extends Span {
  type: 'TSJSDocNullableType';
  typeAnnotation: TSType;
  postfix: boolean;
  parent?: Node$1;
}
interface JSDocNonNullableType extends Span {
  type: 'TSJSDocNonNullableType';
  typeAnnotation: TSType;
  postfix: boolean;
  parent?: Node$1;
}
interface JSDocUnknownType extends Span {
  type: 'TSJSDocUnknownType';
  parent?: Node$1;
}
type AssignmentOperator = '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '**=' | '<<=' | '>>=' | '>>>=' | '|=' | '^=' | '&=' | '||=' | '&&=' | '??=';
type BinaryOperator = '==' | '!=' | '===' | '!==' | '<' | '<=' | '>' | '>=' | '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>' | '|' | '^' | '&' | 'in' | 'instanceof';
type LogicalOperator = '||' | '&&' | '??';
type UnaryOperator = '+' | '-' | '!' | '~' | 'typeof' | 'void' | 'delete';
type UpdateOperator = '++' | '--';
type ModuleKind = 'script' | 'module';
type Node$1 = Program | IdentifierName | IdentifierReference | BindingIdentifier | LabelIdentifier | ThisExpression | ArrayExpression | ObjectExpression | ObjectProperty | TemplateLiteral | TaggedTemplateExpression | TemplateElement | ComputedMemberExpression | StaticMemberExpression | PrivateFieldExpression | CallExpression | NewExpression | MetaProperty | SpreadElement | UpdateExpression | UnaryExpression | BinaryExpression | PrivateInExpression | LogicalExpression | ConditionalExpression | AssignmentExpression | ArrayAssignmentTarget | ObjectAssignmentTarget | AssignmentTargetRest | AssignmentTargetWithDefault | AssignmentTargetPropertyIdentifier | AssignmentTargetPropertyProperty | SequenceExpression | Super | AwaitExpression | ChainExpression | ParenthesizedExpression | Directive | Hashbang | BlockStatement | VariableDeclaration | VariableDeclarator | EmptyStatement | ExpressionStatement | IfStatement | DoWhileStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | SwitchStatement | SwitchCase | LabeledStatement | ThrowStatement | TryStatement | CatchClause | DebuggerStatement | AssignmentPattern | ObjectPattern | BindingProperty | ArrayPattern | BindingRestElement | Function | FunctionBody | ArrowFunctionExpression | YieldExpression | Class | ClassBody | MethodDefinition | PropertyDefinition | PrivateIdentifier | StaticBlock | AccessorProperty | ImportExpression | ImportDeclaration | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportAttribute | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration | ExportSpecifier | V8IntrinsicExpression | BooleanLiteral | NullLiteral | NumericLiteral | StringLiteral | BigIntLiteral | RegExpLiteral | JSXElement | JSXOpeningElement | JSXClosingElement | JSXFragment | JSXOpeningFragment | JSXClosingFragment | JSXNamespacedName | JSXMemberExpression | JSXExpressionContainer | JSXEmptyExpression | JSXAttribute | JSXSpreadAttribute | JSXIdentifier | JSXSpreadChild | JSXText | TSThisParameter | TSEnumDeclaration | TSEnumBody | TSEnumMember | TSTypeAnnotation | TSLiteralType | TSConditionalType | TSUnionType | TSIntersectionType | TSParenthesizedType | TSTypeOperator | TSArrayType | TSIndexedAccessType | TSTupleType | TSNamedTupleMember | TSOptionalType | TSRestType | TSAnyKeyword | TSStringKeyword | TSBooleanKeyword | TSNumberKeyword | TSNeverKeyword | TSIntrinsicKeyword | TSUnknownKeyword | TSNullKeyword | TSUndefinedKeyword | TSVoidKeyword | TSSymbolKeyword | TSThisType | TSObjectKeyword | TSBigIntKeyword | TSTypeReference | TSQualifiedName | TSTypeParameterInstantiation | TSTypeParameter | TSTypeParameterDeclaration | TSTypeAliasDeclaration | TSClassImplements | TSInterfaceDeclaration | TSInterfaceBody | TSPropertySignature | TSIndexSignature | TSCallSignatureDeclaration | TSMethodSignature | TSConstructSignatureDeclaration | TSIndexSignatureName | TSInterfaceHeritage | TSTypePredicate | TSModuleDeclaration | TSModuleBlock | TSTypeLiteral | TSInferType | TSTypeQuery | TSImportType | TSImportTypeQualifiedName | TSFunctionType | TSConstructorType | TSMappedType | TSTemplateLiteralType | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSImportEqualsDeclaration | TSExternalModuleReference | TSNonNullExpression | Decorator | TSExportAssignment | TSNamespaceExportDeclaration | TSInstantiationExpression | JSDocNullableType | JSDocNonNullableType | JSDocUnknownType | ParamPattern;
//#endregion
//#region src-js/generated/visitor.d.ts
interface VisitorObject {
  DebuggerStatement?: (node: DebuggerStatement) => void;
  'DebuggerStatement:exit'?: (node: DebuggerStatement) => void;
  EmptyStatement?: (node: EmptyStatement) => void;
  'EmptyStatement:exit'?: (node: EmptyStatement) => void;
  Literal?: (node: BooleanLiteral | NullLiteral | NumericLiteral | StringLiteral | BigIntLiteral | RegExpLiteral) => void;
  'Literal:exit'?: (node: BooleanLiteral | NullLiteral | NumericLiteral | StringLiteral | BigIntLiteral | RegExpLiteral) => void;
  PrivateIdentifier?: (node: PrivateIdentifier) => void;
  'PrivateIdentifier:exit'?: (node: PrivateIdentifier) => void;
  Super?: (node: Super) => void;
  'Super:exit'?: (node: Super) => void;
  TemplateElement?: (node: TemplateElement) => void;
  'TemplateElement:exit'?: (node: TemplateElement) => void;
  ThisExpression?: (node: ThisExpression) => void;
  'ThisExpression:exit'?: (node: ThisExpression) => void;
  JSXClosingFragment?: (node: JSXClosingFragment) => void;
  'JSXClosingFragment:exit'?: (node: JSXClosingFragment) => void;
  JSXEmptyExpression?: (node: JSXEmptyExpression) => void;
  'JSXEmptyExpression:exit'?: (node: JSXEmptyExpression) => void;
  JSXIdentifier?: (node: JSXIdentifier) => void;
  'JSXIdentifier:exit'?: (node: JSXIdentifier) => void;
  JSXOpeningFragment?: (node: JSXOpeningFragment) => void;
  'JSXOpeningFragment:exit'?: (node: JSXOpeningFragment) => void;
  JSXText?: (node: JSXText) => void;
  'JSXText:exit'?: (node: JSXText) => void;
  TSAnyKeyword?: (node: TSAnyKeyword) => void;
  'TSAnyKeyword:exit'?: (node: TSAnyKeyword) => void;
  TSBigIntKeyword?: (node: TSBigIntKeyword) => void;
  'TSBigIntKeyword:exit'?: (node: TSBigIntKeyword) => void;
  TSBooleanKeyword?: (node: TSBooleanKeyword) => void;
  'TSBooleanKeyword:exit'?: (node: TSBooleanKeyword) => void;
  TSIntrinsicKeyword?: (node: TSIntrinsicKeyword) => void;
  'TSIntrinsicKeyword:exit'?: (node: TSIntrinsicKeyword) => void;
  TSJSDocUnknownType?: (node: JSDocUnknownType) => void;
  'TSJSDocUnknownType:exit'?: (node: JSDocUnknownType) => void;
  TSNeverKeyword?: (node: TSNeverKeyword) => void;
  'TSNeverKeyword:exit'?: (node: TSNeverKeyword) => void;
  TSNullKeyword?: (node: TSNullKeyword) => void;
  'TSNullKeyword:exit'?: (node: TSNullKeyword) => void;
  TSNumberKeyword?: (node: TSNumberKeyword) => void;
  'TSNumberKeyword:exit'?: (node: TSNumberKeyword) => void;
  TSObjectKeyword?: (node: TSObjectKeyword) => void;
  'TSObjectKeyword:exit'?: (node: TSObjectKeyword) => void;
  TSStringKeyword?: (node: TSStringKeyword) => void;
  'TSStringKeyword:exit'?: (node: TSStringKeyword) => void;
  TSSymbolKeyword?: (node: TSSymbolKeyword) => void;
  'TSSymbolKeyword:exit'?: (node: TSSymbolKeyword) => void;
  TSThisType?: (node: TSThisType) => void;
  'TSThisType:exit'?: (node: TSThisType) => void;
  TSUndefinedKeyword?: (node: TSUndefinedKeyword) => void;
  'TSUndefinedKeyword:exit'?: (node: TSUndefinedKeyword) => void;
  TSUnknownKeyword?: (node: TSUnknownKeyword) => void;
  'TSUnknownKeyword:exit'?: (node: TSUnknownKeyword) => void;
  TSVoidKeyword?: (node: TSVoidKeyword) => void;
  'TSVoidKeyword:exit'?: (node: TSVoidKeyword) => void;
  AccessorProperty?: (node: AccessorProperty) => void;
  'AccessorProperty:exit'?: (node: AccessorProperty) => void;
  ArrayExpression?: (node: ArrayExpression) => void;
  'ArrayExpression:exit'?: (node: ArrayExpression) => void;
  ArrayPattern?: (node: ArrayPattern) => void;
  'ArrayPattern:exit'?: (node: ArrayPattern) => void;
  ArrowFunctionExpression?: (node: ArrowFunctionExpression) => void;
  'ArrowFunctionExpression:exit'?: (node: ArrowFunctionExpression) => void;
  AssignmentExpression?: (node: AssignmentExpression) => void;
  'AssignmentExpression:exit'?: (node: AssignmentExpression) => void;
  AssignmentPattern?: (node: AssignmentPattern) => void;
  'AssignmentPattern:exit'?: (node: AssignmentPattern) => void;
  AwaitExpression?: (node: AwaitExpression) => void;
  'AwaitExpression:exit'?: (node: AwaitExpression) => void;
  BinaryExpression?: (node: BinaryExpression) => void;
  'BinaryExpression:exit'?: (node: BinaryExpression) => void;
  BlockStatement?: (node: BlockStatement) => void;
  'BlockStatement:exit'?: (node: BlockStatement) => void;
  BreakStatement?: (node: BreakStatement) => void;
  'BreakStatement:exit'?: (node: BreakStatement) => void;
  CallExpression?: (node: CallExpression) => void;
  'CallExpression:exit'?: (node: CallExpression) => void;
  CatchClause?: (node: CatchClause) => void;
  'CatchClause:exit'?: (node: CatchClause) => void;
  ChainExpression?: (node: ChainExpression) => void;
  'ChainExpression:exit'?: (node: ChainExpression) => void;
  ClassBody?: (node: ClassBody) => void;
  'ClassBody:exit'?: (node: ClassBody) => void;
  ClassDeclaration?: (node: Class) => void;
  'ClassDeclaration:exit'?: (node: Class) => void;
  ClassExpression?: (node: Class) => void;
  'ClassExpression:exit'?: (node: Class) => void;
  ConditionalExpression?: (node: ConditionalExpression) => void;
  'ConditionalExpression:exit'?: (node: ConditionalExpression) => void;
  ContinueStatement?: (node: ContinueStatement) => void;
  'ContinueStatement:exit'?: (node: ContinueStatement) => void;
  Decorator?: (node: Decorator) => void;
  'Decorator:exit'?: (node: Decorator) => void;
  DoWhileStatement?: (node: DoWhileStatement) => void;
  'DoWhileStatement:exit'?: (node: DoWhileStatement) => void;
  ExportAllDeclaration?: (node: ExportAllDeclaration) => void;
  'ExportAllDeclaration:exit'?: (node: ExportAllDeclaration) => void;
  ExportDefaultDeclaration?: (node: ExportDefaultDeclaration) => void;
  'ExportDefaultDeclaration:exit'?: (node: ExportDefaultDeclaration) => void;
  ExportNamedDeclaration?: (node: ExportNamedDeclaration) => void;
  'ExportNamedDeclaration:exit'?: (node: ExportNamedDeclaration) => void;
  ExportSpecifier?: (node: ExportSpecifier) => void;
  'ExportSpecifier:exit'?: (node: ExportSpecifier) => void;
  ExpressionStatement?: (node: ExpressionStatement) => void;
  'ExpressionStatement:exit'?: (node: ExpressionStatement) => void;
  ForInStatement?: (node: ForInStatement) => void;
  'ForInStatement:exit'?: (node: ForInStatement) => void;
  ForOfStatement?: (node: ForOfStatement) => void;
  'ForOfStatement:exit'?: (node: ForOfStatement) => void;
  ForStatement?: (node: ForStatement) => void;
  'ForStatement:exit'?: (node: ForStatement) => void;
  FunctionDeclaration?: (node: Function) => void;
  'FunctionDeclaration:exit'?: (node: Function) => void;
  FunctionExpression?: (node: Function) => void;
  'FunctionExpression:exit'?: (node: Function) => void;
  Identifier?: (node: IdentifierName | IdentifierReference | BindingIdentifier | LabelIdentifier | TSThisParameter | TSIndexSignatureName) => void;
  'Identifier:exit'?: (node: IdentifierName | IdentifierReference | BindingIdentifier | LabelIdentifier | TSThisParameter | TSIndexSignatureName) => void;
  IfStatement?: (node: IfStatement) => void;
  'IfStatement:exit'?: (node: IfStatement) => void;
  ImportAttribute?: (node: ImportAttribute) => void;
  'ImportAttribute:exit'?: (node: ImportAttribute) => void;
  ImportDeclaration?: (node: ImportDeclaration) => void;
  'ImportDeclaration:exit'?: (node: ImportDeclaration) => void;
  ImportDefaultSpecifier?: (node: ImportDefaultSpecifier) => void;
  'ImportDefaultSpecifier:exit'?: (node: ImportDefaultSpecifier) => void;
  ImportExpression?: (node: ImportExpression) => void;
  'ImportExpression:exit'?: (node: ImportExpression) => void;
  ImportNamespaceSpecifier?: (node: ImportNamespaceSpecifier) => void;
  'ImportNamespaceSpecifier:exit'?: (node: ImportNamespaceSpecifier) => void;
  ImportSpecifier?: (node: ImportSpecifier) => void;
  'ImportSpecifier:exit'?: (node: ImportSpecifier) => void;
  LabeledStatement?: (node: LabeledStatement) => void;
  'LabeledStatement:exit'?: (node: LabeledStatement) => void;
  LogicalExpression?: (node: LogicalExpression) => void;
  'LogicalExpression:exit'?: (node: LogicalExpression) => void;
  MemberExpression?: (node: MemberExpression) => void;
  'MemberExpression:exit'?: (node: MemberExpression) => void;
  MetaProperty?: (node: MetaProperty) => void;
  'MetaProperty:exit'?: (node: MetaProperty) => void;
  MethodDefinition?: (node: MethodDefinition) => void;
  'MethodDefinition:exit'?: (node: MethodDefinition) => void;
  NewExpression?: (node: NewExpression) => void;
  'NewExpression:exit'?: (node: NewExpression) => void;
  ObjectExpression?: (node: ObjectExpression) => void;
  'ObjectExpression:exit'?: (node: ObjectExpression) => void;
  ObjectPattern?: (node: ObjectPattern) => void;
  'ObjectPattern:exit'?: (node: ObjectPattern) => void;
  ParenthesizedExpression?: (node: ParenthesizedExpression) => void;
  'ParenthesizedExpression:exit'?: (node: ParenthesizedExpression) => void;
  Program?: (node: Program) => void;
  'Program:exit'?: (node: Program) => void;
  Property?: (node: ObjectProperty | AssignmentTargetProperty | AssignmentTargetPropertyProperty | BindingProperty) => void;
  'Property:exit'?: (node: ObjectProperty | AssignmentTargetProperty | AssignmentTargetPropertyProperty | BindingProperty) => void;
  PropertyDefinition?: (node: PropertyDefinition) => void;
  'PropertyDefinition:exit'?: (node: PropertyDefinition) => void;
  RestElement?: (node: AssignmentTargetRest | BindingRestElement | FormalParameterRest) => void;
  'RestElement:exit'?: (node: AssignmentTargetRest | BindingRestElement | FormalParameterRest) => void;
  ReturnStatement?: (node: ReturnStatement) => void;
  'ReturnStatement:exit'?: (node: ReturnStatement) => void;
  SequenceExpression?: (node: SequenceExpression) => void;
  'SequenceExpression:exit'?: (node: SequenceExpression) => void;
  SpreadElement?: (node: SpreadElement) => void;
  'SpreadElement:exit'?: (node: SpreadElement) => void;
  StaticBlock?: (node: StaticBlock) => void;
  'StaticBlock:exit'?: (node: StaticBlock) => void;
  SwitchCase?: (node: SwitchCase) => void;
  'SwitchCase:exit'?: (node: SwitchCase) => void;
  SwitchStatement?: (node: SwitchStatement) => void;
  'SwitchStatement:exit'?: (node: SwitchStatement) => void;
  TaggedTemplateExpression?: (node: TaggedTemplateExpression) => void;
  'TaggedTemplateExpression:exit'?: (node: TaggedTemplateExpression) => void;
  TemplateLiteral?: (node: TemplateLiteral) => void;
  'TemplateLiteral:exit'?: (node: TemplateLiteral) => void;
  ThrowStatement?: (node: ThrowStatement) => void;
  'ThrowStatement:exit'?: (node: ThrowStatement) => void;
  TryStatement?: (node: TryStatement) => void;
  'TryStatement:exit'?: (node: TryStatement) => void;
  UnaryExpression?: (node: UnaryExpression) => void;
  'UnaryExpression:exit'?: (node: UnaryExpression) => void;
  UpdateExpression?: (node: UpdateExpression) => void;
  'UpdateExpression:exit'?: (node: UpdateExpression) => void;
  V8IntrinsicExpression?: (node: V8IntrinsicExpression) => void;
  'V8IntrinsicExpression:exit'?: (node: V8IntrinsicExpression) => void;
  VariableDeclaration?: (node: VariableDeclaration) => void;
  'VariableDeclaration:exit'?: (node: VariableDeclaration) => void;
  VariableDeclarator?: (node: VariableDeclarator) => void;
  'VariableDeclarator:exit'?: (node: VariableDeclarator) => void;
  WhileStatement?: (node: WhileStatement) => void;
  'WhileStatement:exit'?: (node: WhileStatement) => void;
  WithStatement?: (node: WithStatement) => void;
  'WithStatement:exit'?: (node: WithStatement) => void;
  YieldExpression?: (node: YieldExpression) => void;
  'YieldExpression:exit'?: (node: YieldExpression) => void;
  JSXAttribute?: (node: JSXAttribute) => void;
  'JSXAttribute:exit'?: (node: JSXAttribute) => void;
  JSXClosingElement?: (node: JSXClosingElement) => void;
  'JSXClosingElement:exit'?: (node: JSXClosingElement) => void;
  JSXElement?: (node: JSXElement) => void;
  'JSXElement:exit'?: (node: JSXElement) => void;
  JSXExpressionContainer?: (node: JSXExpressionContainer) => void;
  'JSXExpressionContainer:exit'?: (node: JSXExpressionContainer) => void;
  JSXFragment?: (node: JSXFragment) => void;
  'JSXFragment:exit'?: (node: JSXFragment) => void;
  JSXMemberExpression?: (node: JSXMemberExpression) => void;
  'JSXMemberExpression:exit'?: (node: JSXMemberExpression) => void;
  JSXNamespacedName?: (node: JSXNamespacedName) => void;
  'JSXNamespacedName:exit'?: (node: JSXNamespacedName) => void;
  JSXOpeningElement?: (node: JSXOpeningElement) => void;
  'JSXOpeningElement:exit'?: (node: JSXOpeningElement) => void;
  JSXSpreadAttribute?: (node: JSXSpreadAttribute) => void;
  'JSXSpreadAttribute:exit'?: (node: JSXSpreadAttribute) => void;
  JSXSpreadChild?: (node: JSXSpreadChild) => void;
  'JSXSpreadChild:exit'?: (node: JSXSpreadChild) => void;
  TSAbstractAccessorProperty?: (node: AccessorProperty) => void;
  'TSAbstractAccessorProperty:exit'?: (node: AccessorProperty) => void;
  TSAbstractMethodDefinition?: (node: MethodDefinition) => void;
  'TSAbstractMethodDefinition:exit'?: (node: MethodDefinition) => void;
  TSAbstractPropertyDefinition?: (node: PropertyDefinition) => void;
  'TSAbstractPropertyDefinition:exit'?: (node: PropertyDefinition) => void;
  TSArrayType?: (node: TSArrayType) => void;
  'TSArrayType:exit'?: (node: TSArrayType) => void;
  TSAsExpression?: (node: TSAsExpression) => void;
  'TSAsExpression:exit'?: (node: TSAsExpression) => void;
  TSCallSignatureDeclaration?: (node: TSCallSignatureDeclaration) => void;
  'TSCallSignatureDeclaration:exit'?: (node: TSCallSignatureDeclaration) => void;
  TSClassImplements?: (node: TSClassImplements) => void;
  'TSClassImplements:exit'?: (node: TSClassImplements) => void;
  TSConditionalType?: (node: TSConditionalType) => void;
  'TSConditionalType:exit'?: (node: TSConditionalType) => void;
  TSConstructSignatureDeclaration?: (node: TSConstructSignatureDeclaration) => void;
  'TSConstructSignatureDeclaration:exit'?: (node: TSConstructSignatureDeclaration) => void;
  TSConstructorType?: (node: TSConstructorType) => void;
  'TSConstructorType:exit'?: (node: TSConstructorType) => void;
  TSDeclareFunction?: (node: Function) => void;
  'TSDeclareFunction:exit'?: (node: Function) => void;
  TSEmptyBodyFunctionExpression?: (node: Function) => void;
  'TSEmptyBodyFunctionExpression:exit'?: (node: Function) => void;
  TSEnumBody?: (node: TSEnumBody) => void;
  'TSEnumBody:exit'?: (node: TSEnumBody) => void;
  TSEnumDeclaration?: (node: TSEnumDeclaration) => void;
  'TSEnumDeclaration:exit'?: (node: TSEnumDeclaration) => void;
  TSEnumMember?: (node: TSEnumMember) => void;
  'TSEnumMember:exit'?: (node: TSEnumMember) => void;
  TSExportAssignment?: (node: TSExportAssignment) => void;
  'TSExportAssignment:exit'?: (node: TSExportAssignment) => void;
  TSExternalModuleReference?: (node: TSExternalModuleReference) => void;
  'TSExternalModuleReference:exit'?: (node: TSExternalModuleReference) => void;
  TSFunctionType?: (node: TSFunctionType) => void;
  'TSFunctionType:exit'?: (node: TSFunctionType) => void;
  TSImportEqualsDeclaration?: (node: TSImportEqualsDeclaration) => void;
  'TSImportEqualsDeclaration:exit'?: (node: TSImportEqualsDeclaration) => void;
  TSImportType?: (node: TSImportType) => void;
  'TSImportType:exit'?: (node: TSImportType) => void;
  TSIndexSignature?: (node: TSIndexSignature) => void;
  'TSIndexSignature:exit'?: (node: TSIndexSignature) => void;
  TSIndexedAccessType?: (node: TSIndexedAccessType) => void;
  'TSIndexedAccessType:exit'?: (node: TSIndexedAccessType) => void;
  TSInferType?: (node: TSInferType) => void;
  'TSInferType:exit'?: (node: TSInferType) => void;
  TSInstantiationExpression?: (node: TSInstantiationExpression) => void;
  'TSInstantiationExpression:exit'?: (node: TSInstantiationExpression) => void;
  TSInterfaceBody?: (node: TSInterfaceBody) => void;
  'TSInterfaceBody:exit'?: (node: TSInterfaceBody) => void;
  TSInterfaceDeclaration?: (node: TSInterfaceDeclaration) => void;
  'TSInterfaceDeclaration:exit'?: (node: TSInterfaceDeclaration) => void;
  TSInterfaceHeritage?: (node: TSInterfaceHeritage) => void;
  'TSInterfaceHeritage:exit'?: (node: TSInterfaceHeritage) => void;
  TSIntersectionType?: (node: TSIntersectionType) => void;
  'TSIntersectionType:exit'?: (node: TSIntersectionType) => void;
  TSJSDocNonNullableType?: (node: JSDocNonNullableType) => void;
  'TSJSDocNonNullableType:exit'?: (node: JSDocNonNullableType) => void;
  TSJSDocNullableType?: (node: JSDocNullableType) => void;
  'TSJSDocNullableType:exit'?: (node: JSDocNullableType) => void;
  TSLiteralType?: (node: TSLiteralType) => void;
  'TSLiteralType:exit'?: (node: TSLiteralType) => void;
  TSMappedType?: (node: TSMappedType) => void;
  'TSMappedType:exit'?: (node: TSMappedType) => void;
  TSMethodSignature?: (node: TSMethodSignature) => void;
  'TSMethodSignature:exit'?: (node: TSMethodSignature) => void;
  TSModuleBlock?: (node: TSModuleBlock) => void;
  'TSModuleBlock:exit'?: (node: TSModuleBlock) => void;
  TSModuleDeclaration?: (node: TSModuleDeclaration) => void;
  'TSModuleDeclaration:exit'?: (node: TSModuleDeclaration) => void;
  TSNamedTupleMember?: (node: TSNamedTupleMember) => void;
  'TSNamedTupleMember:exit'?: (node: TSNamedTupleMember) => void;
  TSNamespaceExportDeclaration?: (node: TSNamespaceExportDeclaration) => void;
  'TSNamespaceExportDeclaration:exit'?: (node: TSNamespaceExportDeclaration) => void;
  TSNonNullExpression?: (node: TSNonNullExpression) => void;
  'TSNonNullExpression:exit'?: (node: TSNonNullExpression) => void;
  TSOptionalType?: (node: TSOptionalType) => void;
  'TSOptionalType:exit'?: (node: TSOptionalType) => void;
  TSParameterProperty?: (node: TSParameterProperty) => void;
  'TSParameterProperty:exit'?: (node: TSParameterProperty) => void;
  TSParenthesizedType?: (node: TSParenthesizedType) => void;
  'TSParenthesizedType:exit'?: (node: TSParenthesizedType) => void;
  TSPropertySignature?: (node: TSPropertySignature) => void;
  'TSPropertySignature:exit'?: (node: TSPropertySignature) => void;
  TSQualifiedName?: (node: TSQualifiedName) => void;
  'TSQualifiedName:exit'?: (node: TSQualifiedName) => void;
  TSRestType?: (node: TSRestType) => void;
  'TSRestType:exit'?: (node: TSRestType) => void;
  TSSatisfiesExpression?: (node: TSSatisfiesExpression) => void;
  'TSSatisfiesExpression:exit'?: (node: TSSatisfiesExpression) => void;
  TSTemplateLiteralType?: (node: TSTemplateLiteralType) => void;
  'TSTemplateLiteralType:exit'?: (node: TSTemplateLiteralType) => void;
  TSTupleType?: (node: TSTupleType) => void;
  'TSTupleType:exit'?: (node: TSTupleType) => void;
  TSTypeAliasDeclaration?: (node: TSTypeAliasDeclaration) => void;
  'TSTypeAliasDeclaration:exit'?: (node: TSTypeAliasDeclaration) => void;
  TSTypeAnnotation?: (node: TSTypeAnnotation) => void;
  'TSTypeAnnotation:exit'?: (node: TSTypeAnnotation) => void;
  TSTypeAssertion?: (node: TSTypeAssertion) => void;
  'TSTypeAssertion:exit'?: (node: TSTypeAssertion) => void;
  TSTypeLiteral?: (node: TSTypeLiteral) => void;
  'TSTypeLiteral:exit'?: (node: TSTypeLiteral) => void;
  TSTypeOperator?: (node: TSTypeOperator) => void;
  'TSTypeOperator:exit'?: (node: TSTypeOperator) => void;
  TSTypeParameter?: (node: TSTypeParameter) => void;
  'TSTypeParameter:exit'?: (node: TSTypeParameter) => void;
  TSTypeParameterDeclaration?: (node: TSTypeParameterDeclaration) => void;
  'TSTypeParameterDeclaration:exit'?: (node: TSTypeParameterDeclaration) => void;
  TSTypeParameterInstantiation?: (node: TSTypeParameterInstantiation) => void;
  'TSTypeParameterInstantiation:exit'?: (node: TSTypeParameterInstantiation) => void;
  TSTypePredicate?: (node: TSTypePredicate) => void;
  'TSTypePredicate:exit'?: (node: TSTypePredicate) => void;
  TSTypeQuery?: (node: TSTypeQuery) => void;
  'TSTypeQuery:exit'?: (node: TSTypeQuery) => void;
  TSTypeReference?: (node: TSTypeReference) => void;
  'TSTypeReference:exit'?: (node: TSTypeReference) => void;
  TSUnionType?: (node: TSUnionType) => void;
  'TSUnionType:exit'?: (node: TSUnionType) => void;
  [key: string]: (node: Node$1) => void;
}
//#endregion
//#region src-js/plugins/types.d.ts
type BeforeHook = () => boolean | void;
type AfterHook = () => void;
interface VisitorWithHooks extends VisitorObject {
  before?: BeforeHook;
  after?: AfterHook;
}
type Range = [number, number];
interface Ranged {
  range: Range;
}
interface Span extends Ranged {
  start: number;
  end: number;
  loc: Location;
}
interface Location {
  start: LineColumn;
  end: LineColumn;
}
interface LineColumn {
  line: number;
  column: number;
}
interface Node extends Span {}
interface Token extends Span {
  type: string;
  value: string;
}
type NodeOrToken = Node | Token;
interface Comment extends Span {
  type: 'Line' | 'Block';
  value: string;
}
interface RuleMeta {
  fixable?: 'code' | 'whitespace' | null | undefined;
  messages?: Record<string, string>;
  [key: string]: unknown;
}
//#endregion
//#region src-js/plugins/fix.d.ts
type FixFn = (fixer: Fixer) => Fix | Array<Fix | null | undefined> | IterableIterator<Fix | null | undefined> | null | undefined;
type Fix = {
  range: Range;
  text: string;
};
declare const FIXER: Readonly<{
  insertTextBefore(nodeOrToken: Ranged, text: string): Fix;
  insertTextBeforeRange(range: Range, text: string): Fix;
  insertTextAfter(nodeOrToken: Ranged, text: string): Fix;
  insertTextAfterRange(range: Range, text: string): Fix;
  remove(nodeOrToken: Ranged): Fix;
  removeRange(range: Range): Fix;
  replaceText(nodeOrToken: Ranged, text: string): Fix;
  replaceTextRange(range: Range, text: string): Fix;
}>;
type Fixer = typeof FIXER;
//#endregion
//#region src-js/plugins/location.d.ts
/**
 * Convert a source text index into a (line, column) pair.
 * @param offset - The index of a character in a file.
 * @returns `{line, column}` location object with 1-indexed line and 0-indexed column.
 * @throws {TypeError|RangeError} If non-numeric `offset`, or `offset` out of range.
 */
declare function getLineColumnFromOffset(offset: number): LineColumn;
/**
 * Convert a `{ line, column }` pair into a range index.
 * @param loc - A line/column location.
 * @returns The character index of the location in the file.
 * @throws {TypeError|RangeError} If `loc` is not an object with a numeric `line` and `column`,
 *   or if the `line` is less than or equal to zero, or the line or column is out of the expected range.
 */
declare function getOffsetFromLineColumn(loc: LineColumn): number;
//#endregion
//#region src-js/plugins/scope.d.ts
type Identifier = IdentifierName | IdentifierReference | BindingIdentifier | LabelIdentifier | TSThisParameter | TSIndexSignatureName;
declare class ScopeManager {}
interface Scope {
  type: ScopeType;
  isStrict: boolean;
  upper: Scope | null;
  childScopes: Scope[];
  variableScope: Scope;
  block: Node;
  variables: Variable[];
  set: Map<string, Variable>;
  references: Reference[];
  through: Reference[];
  functionExpressionScope: boolean;
  implicit?: {
    variables: Variable[];
    set: Map<string, Variable>;
  };
}
type ScopeType = 'block' | 'catch' | 'class' | 'class-field-initializer' | 'class-static-block' | 'for' | 'function' | 'function-expression-name' | 'global' | 'module' | 'switch' | 'with';
interface Variable {
  name: string;
  scope: Scope;
  identifiers: Identifier[];
  references: Reference[];
  defs: Definition[];
}
interface Reference {
  identifier: Identifier;
  from: Scope;
  resolved: Variable | null;
  writeExpr: Expression | null;
  init: boolean;
  isWrite(): boolean;
  isRead(): boolean;
  isReadOnly(): boolean;
  isWriteOnly(): boolean;
  isReadWrite(): boolean;
}
interface Definition {
  type: DefinitionType;
  name: Identifier;
  node: Node;
  parent: Node | null;
}
type DefinitionType = 'CatchClause' | 'ClassName' | 'FunctionName' | 'ImplicitGlobalVariable' | 'ImportBinding' | 'Parameter' | 'Variable';
//#endregion
//#region src-js/plugins/source_code.d.ts
declare const SOURCE_CODE: Readonly<{
  readonly text: string;
  readonly hasBOM: boolean;
  readonly ast: Program;
  readonly scopeManager: ScopeManager;
  readonly visitorKeys: {
    [key: string]: string[];
  };
  readonly parserServices: {
    [key: string]: unknown;
  };
  readonly lines: string[];
  /**
   * Get the source code for the given node.
   * @param node? - The AST node to get the text for.
   * @param beforeCount? - The number of characters before the node to retrieve.
   * @param afterCount? - The number of characters after the node to retrieve.
   * @returns Source text representing the AST node.
   */
  getText(node?: Ranged | null | undefined, beforeCount?: number | null | undefined, afterCount?: number | null | undefined): string;
  /**
   * Retrieve an array containing all comments in the source code.
   * @returns Array of `Comment`s in occurrence order.
   */
  getAllComments(): Comment[];
  /**
   * Get all comment tokens directly before the given node or token.
   * @param nodeOrToken - The AST node or token to check for adjacent comment tokens.
   * @returns Array of `Comment`s in occurrence order.
   */
  getCommentsBefore(nodeOrToken: NodeOrToken): Comment[];
  /**
   * Get all comment tokens directly after the given node or token.
   * @param nodeOrToken - The AST node or token to check for adjacent comment tokens.
   * @returns Array of `Comment`s in occurrence order.
   */
  getCommentsAfter(nodeOrToken: NodeOrToken): Comment[];
  /**
   * Get all comment tokens inside the given node.
   * @param node - The AST node to get the comments for.
   * @returns Array of `Comment`s in occurrence order.
   */
  getCommentsInside(node: Node): Comment[];
  /**
   * Determine if two nodes or tokens have at least one whitespace character between them.
   * Order does not matter. Returns `false` if the given nodes or tokens overlap.
   * @param nodeOrToken1 - The first node or token to check between.
   * @param nodeOrToken2 - The second node or token to check between.
   * @returns `true` if there is a whitespace character between
   *   any of the tokens found between the two given nodes or tokens.
   */
  isSpaceBetween(nodeOrToken1: NodeOrToken, nodeOrToken2: NodeOrToken): boolean;
  /**
   * Determine whether the given identifier node is a reference to a global variable.
   * @param node - `Identifier` node to check.
   * @returns `true` if the identifier is a reference to a global variable.
   */
  isGlobalReference(node: Node): boolean;
  /**
   * Get all tokens that are related to the given node.
   * @param node - The AST node.
   * @param countOptions? - Options object. If this is a function then it's `options.filter`.
   * @returns Array of `Token`s.
   */
  /**
   * Get all tokens that are related to the given node.
   * @param node - The AST node.
   * @param beforeCount? - The number of tokens before the node to retrieve.
   * @param afterCount? - The number of tokens after the node to retrieve.
   * @returns Array of `Token`s.
   */
  getTokens(node: Node, countOptions?: CountOptions | number | FilterFn | null | undefined, afterCount?: number | null | undefined): Token[];
  /**
   * Get the first token of the given node.
   * @param node - The AST node.
   * @param skipOptions? - Options object. If this is a number then it's `options.skip`.
   *   If this is a function then it's `options.filter`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getFirstToken(node: Node, skipOptions?: SkipOptions | number | FilterFn | null | undefined): Token | null;
  /**
   * Get the first tokens of the given node.
   * @param node - The AST node.
   * @param countOptions? - Options object. If this is a number then it's `options.count`.
   *   If this is a function then it's `options.filter`.
   * @returns Array of `Token`s.
   */
  getFirstTokens(node: Node, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the last token of the given node.
   * @param node - The AST node.
   * @param skipOptions? - Options object. Same options as `getFirstToken()`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getLastToken(node: Node, skipOptions?: SkipOptions | number | FilterFn | null | undefined): Token | null;
  /**
   * Get the last tokens of the given node.
   * @param node - The AST node.
   * @param countOptions? - Options object. Same options as `getFirstTokens()`.
   * @returns Array of `Token`s.
   */
  getLastTokens(node: Node, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the token that precedes a given node or token.
   * @param nodeOrToken - The AST node or token.
   * @param skipOptions? - Options object. Same options as `getFirstToken()`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getTokenBefore(nodeOrToken: NodeOrToken | Comment, skipOptions?: SkipOptions | number | FilterFn | null | undefined): Token | null;
  /**
   * Get the tokens that precedes a given node or token.
   * @param nodeOrToken - The AST node or token.
   * @param countOptions? - Options object. Same options as `getFirstTokens()`.
   * @returns Array of `Token`s.
   */
  getTokensBefore(nodeOrToken: NodeOrToken | Comment, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the token that follows a given node or token.
   * @param nodeOrToken - The AST node or token.
   * @param skipOptions? - Options object. Same options as `getFirstToken()`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getTokenAfter(nodeOrToken: NodeOrToken | Comment, skipOptions?: SkipOptions | number | FilterFn | null | undefined): Token | null;
  /**
   * Get the tokens that follow a given node or token.
   * @param nodeOrToken - The AST node or token.
   * @param countOptions? - Options object. Same options as `getFirstTokens()`.
   * @returns Array of `Token`s.
   */
  getTokensAfter(nodeOrToken: NodeOrToken | Comment, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get all of the tokens between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param countOptions? - Options object. If this is a function then it's `options.filter`.
   * @returns Array of `Token`s between `nodeOrToken1` and `nodeOrToken2`.
   */
  /**
   * Get all of the tokens between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param padding - Number of extra tokens on either side of center.
   * @returns Array of `Token`s between `nodeOrToken1` and `nodeOrToken2`.
   */
  getTokensBetween(nodeOrToken1: NodeOrToken | Comment, nodeOrToken2: NodeOrToken | Comment, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the first token between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param countOptions? - Options object. Same options as `getFirstToken()`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getFirstTokenBetween(nodeOrToken1: NodeOrToken | Comment, nodeOrToken2: NodeOrToken | Comment, skipOptions?: SkipOptions | null | undefined): Token | null;
  /**
   * Get the first tokens between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param countOptions? - Options object. Same options as `getFirstTokens()`.
   * @returns Array of `Token`s between `nodeOrToken1` and `nodeOrToken2`.
   */
  getFirstTokensBetween(nodeOrToken1: NodeOrToken | Comment, nodeOrToken2: NodeOrToken | Comment, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the last token between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param skipOptions? - Options object. Same options as `getFirstToken()`.
   * @returns `Token`, or `null` if all were skipped.
   */
  getLastTokenBetween(nodeOrToken1: NodeOrToken | Comment, nodeOrToken2: NodeOrToken | Comment, skipOptions?: SkipOptions | null | undefined): Token | null;
  /**
   * Get the last tokens between two non-overlapping nodes.
   * @param nodeOrToken1 - Node before the desired token range.
   * @param nodeOrToken2 - Node after the desired token range.
   * @param countOptions? - Options object. Same options as `getFirstTokens()`.
   * @returns Array of `Token`s between `nodeOrToken1` and `nodeOrToken2`.
   */
  getLastTokensBetween(nodeOrToken1: NodeOrToken | Comment, nodeOrToken2: NodeOrToken | Comment, countOptions?: CountOptions | number | FilterFn | null | undefined): Token[];
  /**
   * Get the token starting at the specified index.
   * @param index - Index of the start of the token's range.
   * @param options - Options object.
   * @returns The token starting at index, or `null` if no such token.
   */
  getTokenByRangeStart(index: number, rangeOptions?: RangeOptions | null | undefined): Token | null;
  /**
   * Get the deepest node containing a range index.
   * @param index Range index of the desired node.
   * @returns The node if found, or `null` if not found.
   */
  getNodeByRangeIndex(index: number): Node | null;
  getLocFromIndex: typeof getLineColumnFromOffset;
  getIndexFromLoc: typeof getOffsetFromLineColumn;
  /**
   * Check whether any comments exist or not between the given 2 nodes.
   * @param nodeOrToken1 - The node to check.
   * @param nodeOrToken2 - The node to check.
   * @returns `true` if one or more comments exist.
   */
  commentsExistBetween(nodeOrToken1: NodeOrToken, nodeOrToken2: NodeOrToken): boolean;
  getAncestors: typeof getAncestors;
  /**
   * Get the variables that `node` defines.
   * This is a convenience method that passes through to the same method on the `scopeManager`.
   * @param node - The node for which the variables are obtained.
   * @returns An array of variable nodes representing the variables that `node` defines.
   */
  getDeclaredVariables(node: Node): Variable[];
  /**
   * Get the scope for the given node
   * @param node - The node to get the scope of.
   * @returns The scope information for this node.
   */
  getScope(node: Node): Scope;
  /**
   * Mark a variable as used in the current scope
   * @param name - The name of the variable to mark as used.
   * @param refNode? - The closest node to the variable reference.
   * @returns `true` if the variable was found and marked as used, `false` if not.
   */
  markVariableAsUsed(name: string, refNode: Node): boolean;
}>;
type SourceCode = typeof SOURCE_CODE;
/**
 * Get all the ancestors of a given node.
 * @param node - AST node
 * @returns All the ancestor nodes in the AST, not including the provided node,
 *   starting from the root node at index 0 and going inwards to the parent node.
 */
declare function getAncestors(node: Node): Node[];
interface SkipOptions {
  skip?: number;
  includeComments?: boolean;
  filter?: FilterFn | null;
}
interface CountOptions {
  count?: number;
  includeComments?: boolean;
  filter?: FilterFn | null;
}
interface RangeOptions {
  includeComments?: boolean;
}
type FilterFn = (token: Token) => boolean;
//#endregion
//#region src-js/plugins/context.d.ts
type Diagnostic = DiagnosticWithNode | DiagnosticWithLoc;
interface DiagnosticBase {
  message?: string | null | undefined;
  messageId?: string | null | undefined;
  data?: Record<string, string | number> | null | undefined;
  fix?: FixFn;
}
interface DiagnosticWithNode extends DiagnosticBase {
  node: Ranged;
}
interface DiagnosticWithLoc extends DiagnosticBase {
  loc: Location;
}
/**
 * Context class.
 *
 * Each rule has its own `Context` object. It is passed to that rule's `create` function.
 */
declare class Context {
  #private;
  /**
   * @class
   * @param fullRuleName - Rule name, in form `<plugin>/<rule>`
   * @param isFixable - Whether the rule can provide fixes
   * @param messages - Message templates for `messageId` support (or `null` if none)
   */
  constructor(fullRuleName: string, isFixable: boolean, messages: Record<string, string> | null);
  get id(): string;
  get filename(): string;
  get physicalFilename(): string;
  get options(): unknown[];
  get sourceCode(): SourceCode;
  /**
   * Report error.
   * @param diagnostic - Diagnostic object
   * @throws {TypeError} If `diagnostic` is invalid
   */
  report(diagnostic: Diagnostic): void;
}
//#endregion
//#region src-js/plugins/load.d.ts
interface Plugin {
  meta: {
    name: string;
  };
  rules: {
    [key: string]: Rule;
  };
}
type Rule = CreateRule | CreateOnceRule;
interface CreateRule {
  meta?: RuleMeta;
  create: (context: Context) => VisitorObject;
}
interface CreateOnceRule {
  meta?: RuleMeta;
  create?: (context: Context) => VisitorObject;
  createOnce: (context: Context) => VisitorWithHooks;
}
//#endregion
//#region src-js/index.d.ts
/**
 * Define a plugin.
 *
 * If any of the plugin's rules use the Oxlint alternative `createOnce` API,
 * add ESLint-compatible `create` methods to those rules, which delegate to `createOnce`.
 * This makes the plugin compatible with ESLint.
 *
 * The `plugin` object passed in is mutated in-place.
 *
 * @param plugin - Plugin to define
 * @returns Plugin with all rules having `create` method
 * @throws {Error} If `plugin` is not an object, or `plugin.rules` is not an object
 */
declare function definePlugin(plugin: Plugin): Plugin;
/**
 * Define a rule.
 *
 * If `rule` uses the Oxlint alternative `createOnce` API, add an ESLint-compatible
 * `create` method to the rule, which delegates to `createOnce`.
 * This makes the rule compatible with ESLint.
 *
 * The `rule` object passed in is mutated in-place.
 *
 * @param rule - Rule to define
 * @returns Rule with `create` method
 * @throws {Error} If `rule` is not an object
 */
declare function defineRule(rule: Rule): Rule;
//#endregion
export { type AfterHook, type BeforeHook, type Comment, type Context, type CountOptions, type CreateOnceRule, type CreateRule, type Definition, type DefinitionType, type Diagnostic, type DiagnosticBase, type DiagnosticWithLoc, type DiagnosticWithNode, type types_d_exports as ESTree, type FilterFn, type Fix, type FixFn, type Fixer, type LineColumn, type Location, type Node, type NodeOrToken, type Plugin, type Range, type RangeOptions, type Ranged, type Reference, type Rule, type RuleMeta, type Scope, type ScopeManager, type ScopeType, type SkipOptions, type SourceCode, type Span, type Token, type Variable, type VisitorObject as Visitor, type VisitorWithHooks, definePlugin, defineRule };